{"pageProps":{"post":{"title":"Java 8 New Language Features","excerpt":"This post discusses the new features introduced to Java 8 language.","date":"2019-07-06","image":{"cover":"","og":""},"slug":"java-8-new-language-features","content":"\r\n### Overview\r\n\r\nThis post discusses the new language features of **Java 8**. Java 8's release is the most awaited and is a major feature release of Java programming language.\r\n\r\nThese new features include **functional interfaces**, **interface default method**, **lambda expressions**, **method references**, **Optional**, and **Stream API**. We will also talk about some of **built-in functions** that implement Function Interface and the **New Date and Time API**.\r\n\r\n### Functional Interface\r\n\r\nFunctional Interface is an interface with **single abstract method (SAM)**. Static or the new default method is not counted. To indicate that an interface is a **Functional Interface**, annotation `@FunctionalInterface` on class level is needed. While an interface with SAM could still function as **Functional Interface** (qualified as lambda expression) even if it does not have such annotation (example is AWT's `ActionListener`), it is recommended that it be annotated.\r\n\r\nSome old built-in interfaces with SAM, such as `Comparator` and `Runnable`, have been annotated with `@FunctionalInterface` and can be used as lambda expressions.\r\n\r\n#### Example\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Calculator {\r\n  long calculate(long x, long y);\r\n}\r\n```\r\n\r\nWe can implement above interface in two ways prior to Java 8.\r\n\r\n- Anonymous class\r\n\r\n  ```java\r\n  Calculator division = new Calculator() {\r\n    @Override\r\n    public long calculate(long x, long y) {\r\n      return x / y;\r\n    }\r\n  };\r\n\r\n  long quotient = division.calculate(10, 2);\r\n  ```\r\n\r\n- Concrete class\r\n\r\n  ```java\r\n  class Division implements Calculator {\r\n    @Override\r\n      public long calculate(long x, long y) {\r\n      return x / y;\r\n    }\r\n  }\r\n  ```\r\n\r\n  ```java\r\n  Calculator division = new Division() ;\r\n  long quotient = division.calculate(10, 2);\r\n  ```\r\n\r\nWith Java 8, there is a third way to to implement an interface and that is by using **Lambda Expressions**.\r\n\r\n### Lambda Expressions\r\n\r\nLambda expressions encapsulate a single unit of behavior and pass it to other code. To be able to create lambda expression, you need first a Funtional Interface. This is the reason why a Functional Interface has a single abstract method. Instead of an anonymous class, you can use lambda expression which is a concise alternative and shorthand replacement for it.\r\n\r\n#### Syntax\r\n\r\n```java\r\nparameter -> expression or statement body\r\n```\r\n\r\n#### Example\r\n\r\n```java\r\n(Integer x) -> { return x; };\r\n```\r\n\r\n#### Characteristics of Lambda Expression\r\n\r\n1. Optional type declaration\r\n\r\n```java\r\n(x) -> { return x; };\r\n```\r\n\r\n2. Optional parentheses<br>\r\n\r\n```java\r\nx -> { return x; };\r\n```\r\n\r\nParentheses are required if there are multiple parameters. Parameters are separated by comma (`,`).\r\n\r\n```java\r\n(x, y) -> { return x + y; };\r\n```\r\n\r\n3. Optional curly braces (`{}`) and optional `return` keyword\r\n\r\n```java\r\nx -> x;\r\n```\r\n\r\nCurly braces are required if body has multiple statements. `return` keyword is required for a function with return value if body has multiple statements. No `return` keyword is required if function does not return a value as in regular method.\r\n\r\n```java\r\nx -> {\r\n  System.out.println(\"Hello world!\");\r\n  return x;\r\n};\r\n```\r\n\r\n```java\r\nx -> {\r\n  System.out.println(\"Hello world!\");\r\n  System.out.println(\"Welcome to Java 8 Programming!\");\r\n};\r\n```\r\n\r\nRemember our `Calculator` interface? Here is how to implement it using lambda expression:\r\n\r\n```java\r\nCalculator multiplication = (a, b) -> a * b;    // or (a, b) -> Math.multiplyExact(a, b);\r\nCalculator division = (a, b) -> a / b;\r\nCalculator addition = (a, b) -> a + b;          // or (a, b) -> Math.addExact(a, b);\r\nCalculator subtraction = (a, b) -> a - b;       // or (a, b) -> Math.subtractExact(a, b);\r\n\r\nlong product = multiplication.calculate(5, 5);\r\nlong quotient = division.calculate(10, 2);\r\nlong sum = addition.calculate(5, 5);\r\nlong difference = subtraction.calculate(10, 4);\r\n```\r\n\r\n### Built-in Functions\r\n\r\nJava 8 ships 43 built-in functions under `java.util.function` package. **Thirty eight** (**38**) of them are specialization for primitive and other functions.\r\n\r\nThe following are the basic functions:\r\n\r\n1. `Function`\r\n2. `Consumer`\r\n3. `Supplier`\r\n4. `Predicate`\r\n\r\n#### Function\r\n\r\nFunction represents a function that accepts one argument and produces a result. The type parameter `T` represents the type of the input to the function while the second one R represents the type of result. The functonal method of this functional interface is `apply(Object)`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Function<T,R>\r\n```\r\n\r\n##### Examples\r\n\r\nBelow is an example of Function that accepts a String argument and returns a String.\r\n\r\n```java\r\nFunction<String, String> f1 = a -> a;\r\nString message = f1.apply(\"Welcome to Java 8!\");\r\n```\r\n\r\nThis one accepts a String argument and returns an integer.\r\n\r\n```java\r\nFunction<String, Integer> f2 = a -> a.length();\r\nint textLength = f2.apply(\"Welcome to Java 8!\");\r\n```\r\n\r\n#### Consumer\r\n\r\nConsumer represents an operation that accepts a single input argument and returns no result. The type parameter `T` represents the type of the input to the operation. The functonal method of this functional interface is `accept(Object)`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Consumer<T>\r\n```\r\n\r\n##### Examples\r\n\r\nBoth accept String input argument and returns no value.\r\n\r\n```java\r\nConsumer<String> c1 = a -> System.out.println(a);\r\nc1.accept(\"Welcome to Java 8!\");\r\n\r\nConsumer<String> c2 = a -> {\r\n  String message = \"Welcome to \" + a + \"!\";\r\n  System.out.println(message);\r\n};\r\nc2.accept(\"Java 8\");\r\n```\r\n\r\n#### Supplier\r\n\r\nSupplier Represents a supplier of results. The type parameter `T` represents the type of results supplied by the supplier. This is a functional interface whose functional method is `get()`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Supplier<T>\r\n```\r\n\r\n##### Examples\r\n\r\nThis example returns a value of String type.\r\n\r\n```java\r\nSupplier<String> stringSupplier = () -> \"Welcome to Java 8!\";\r\nString message = stringSupplier.get();\r\n```\r\n\r\nAnd this one returns a value of User type.\r\n\r\n```java\r\nSupplier<User> userSupplier = () -> new User();\r\nUser user = userSupplier.get();\r\n```\r\n\r\n#### Predicate\r\n\r\nPredicate represents a predicate (boolean-valued function) of one argument. The type parameter `T` represents the type of the input to the predicate. This is a functional interface whose functional method is `test(Object)`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Predicate<T>\r\n```\r\n\r\n##### Examples\r\n\r\nTo check if argument is equal to \"YES\" regardless of case:\r\n\r\n```java\r\nPredicate<String> answerPredicate = a -> \"YES\".equalsIgnoreCase(a);\r\nboolean isYes = answerPredicate.test(\"Yes\");\r\n```\r\n\r\nTo check if person is of legal age (18 and above):\r\n\r\n```java\r\npublic static Predicate<Integer> isLegalAge() {\r\n  return age -> age >= 18;\r\n}\r\n```\r\n\r\n```java\r\nboolean legalAge = isLegalAge().test(18);\r\n```\r\n\r\n#### Built-in Functions - Specialization\r\n\r\nOther built-in functions are specializations for primitive types and for basic or another specialization functions.\r\n\r\nTo check all other built-in functions, please visit this <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html\" target=\"blank\">Javadoc</a>.\r\n\r\n#### Existing Interface - Comparator\r\n\r\n`Comparator` is an existing interface in Java since version 1.2. This interface has a single abstract method, `compare(T o1, T o2)`, and, therefore, can be used as lambda expression similar to functions added to Java 8.\r\n\r\nPrior to Java 8, we would use <span class=\"inline-code\">Comparator</span> in sorting a collection the following way:\r\n\r\n```java\r\nList<String> choices = Arrays.asList(\"c\", \"a\", \"d\", \"b\", \"e\");\r\n\r\nCollections.sort(choices, new Comparator<String>() {\r\n  @Override\r\n  public int compare(String a, String b) {\r\n    return a.compareTo(b);\r\n  }\r\n});\r\n```\r\n\r\nWith Java 8:\r\n\r\n```java\r\nComparator<String> comparator = (a, b) -> a.compareTo(b);\r\nCollections.sort(choices, comparator);\r\n```\r\n\r\n```java\r\nCollections.sort(choices, (String a, String b) -> {\r\n  return a.compareTo(b);\r\n});\r\n```\r\n\r\n```java\r\nCollections.sort(choices, (String a, String b) -> a.compareTo(b));\r\n```\r\n\r\n```java\r\nCollections.sort(choices, (a, b) -> a.compareTo(b));\r\n```\r\n\r\n### Default Methods\r\n\r\nDefault methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces. They are interface methods that have an implementation, similar to static methods, and the `default` keyword at the beginning of the method signature.\r\n\r\n#### Syntax</h4>\r\n\r\n```java\r\ndefault type methodName(type parameter) {\r\n  body\r\n}\r\n```\r\n\r\nFor example, default method `forEach()` was added to `Iterable` interface. This method takes a `Consumer` argument and performs action for each element (similar to enhanced `for-each` construct). `List` interface which extends `Iterable` can now be used with `forEach()` method:\r\n\r\n```java\r\nList<String> days = Arrays.asList(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\");\r\ndays.forEach(day -> System.out.println(day));\r\n```\r\n\r\n#### Example\r\n\r\n```java\r\npublic interface Calculator {\r\n  double calculate(double number);\r\n\r\n  default double sqrt(double number) {\r\n    return Math.sqrt(number);\r\n  }\r\n}\r\n```\r\n\r\n```java\r\nCalculator sc = x -> x * x;\r\ndouble square = sc.calculate(10.0); // 100.0\r\ndouble sqrt = sc.sqrt(square);      // 10.0\r\n```\r\n\r\n### Method References\r\n\r\nJava 8 enables you to pass references of methods or constructors via the :: keyword. Method references are compact, easy-to-read lambda expressions for methods that already have a name. They are preferred over lambda expression if the expression does nothing but calls an existing method.\r\n\r\n#### Syntax\r\n\r\n```java\r\nReference::methodName\r\n```\r\n\r\n#### Types of Method References\r\n\r\n<table class=\"table table-bordered table-striped\">\r\n    <thead>\r\n        <tr>\r\n            <th scope=\"col\">Type</th>\r\n            <th scope=\"col\">Example</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <th scope=\"row\">Reference to a static method</th>\r\n            <td>ContainingClass::staticMethodName</td>\r\n        </tr>\r\n        <tr>\r\n            <th scope=\"row\">Reference to an instance method of a particular object</th>\r\n            <td>containingObject::instanceMethodName</td>\r\n        </tr>\r\n        <tr>\r\n            <th scope=\"row\">Reference to an instance method of an arbitrary object of a particular type</th>\r\n            <td>ContainingType::methodName</td>\r\n        </tr>\r\n        <tr>\r\n            <th scope=\"row\">Reference to a constructor</th>\r\n            <td>ClassName::new</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n#### Example\r\n\r\n##### Reference to a static method\r\n\r\n1. Example 1\r\n\r\n```java\r\nclass Person {\r\n  private LocalDate birthday;\r\n\r\n  public Person() {}\r\n\r\n  public Person(LocalDate birthday) {\r\n    this.birthday = birthday;\r\n  }\r\n\r\n  // setters, getters\r\n\r\n  public static int compareByAge(Person a, Person b) {\r\n    return a.birthday.compareTo(b.birthday);\r\n  }\r\n}\r\n```\r\n\r\n```java\r\nPerson p1 = new Person(LocalDate.of(2000, 6, 21));\r\nPerson p2 = new Person(LocalDate.of(2000, 6, 15));\r\nPerson p3 = new Person(LocalDate.of(1998, 3, 28));\r\nPerson[] persons = {p1, p2, p3};\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nArrays.sort(persons, (p1, p2) -> Person.compareByAge(p1, p2));\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nArrays.sort(persons, Person::compareByAge);\r\n```\r\n\r\n1. Example 2\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface StringToIntConverter {\r\n  int convert(String string);\r\n}\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nStringToIntConverter converter = s -> Integer.valueOf(s);\r\nint i = converter.convert(\"10\");\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nStringToIntConverter converter = Integer::valueOf;\r\nint i = converter.convert(\"10\");\r\n```\r\n\r\n##### Reference to an instance method of a particular object\r\n\r\n1. Example 1\r\n\r\n```java\r\npublic class Something {\r\n  public int getYear(LocalDate localDate) {\r\n    return localDate.getYear();\r\n  }\r\n}\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nSomething something = new Something();\r\nFunction<LocalDate, Integer> f = d -> something.getYear(d);\r\nint year = f.apply(p1.getBirthday());\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nSomething something = new Something();\r\nFunction<LocalDate, Integer> f = something::getYear;\r\nint year = f.apply(p1.getBirthday());\r\n```\r\n\r\n2. Example 2\r\n\r\n```java\r\npublic interface PersonDao {\r\n  Person findById(int id);\r\n}\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nPersonDao personDao = new PersonDaoImpl();\r\nFunction<Integer, Person> f = id -> personDao.findById(id);\r\nPerson person = f.apply(1);\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nPersonDao personDao = new PersonDaoImpl();\r\nFunction<Integer, Person > f = personDao::findById;\r\nPerson person = f.apply(1);\r\n```\r\n\r\n##### Reference to an instance method of an arbitrary object of a particular type\r\n\r\n1. Example 1\r\n\r\nLambda Expression\r\n\r\n```java\r\nFunction<String, String> f = s -> s.toUpperCase();\r\nString httpGet = f.apply(\"get\");\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nFunction<String, String> f = String::toUpperCase;\r\nString httpGet = f.apply(\"get\");\r\n```\r\n\r\n2. Example 2\r\n\r\nLambda Expression\r\n\r\n```java\r\nPerson person = ...\r\nFunction<Person, LocalDate> f = p -> p.getBirthday();\r\nLocalDate birthday = f.apply(person);\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nPerson person = ...\r\nFunction<Person, LocalDate> f = Person::getBirthday;\r\nLocalDate birthday = f.apply(person);\r\n```\r\n\r\n##### Reference to a constructor</h5>\r\n\r\n1. Example 1\r\n\r\nLambda Expression\r\n\r\n```java\r\nFunction<LocalDate, Person> f = d -> new Person(d);\r\nLocalDate birthday = LocalDate.of(2000, 10, 12);\r\nPerson person = f.apply(birthday);\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nFunction<LocalDate, Person> f = Person::new;\r\nLocalDate birthday = LocalDate.of(2000, 10, 12);\r\nPerson person = f.apply(birthday);\r\n```\r\n\r\n2. Example 2\r\n\r\nLambda Expression\r\n\r\n```java\r\nSupplier<Person> s = () -> new Person();\r\nPerson person = s.get();\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nSupplier<Person> s = Person::new;\r\nPerson person = s.get();\r\n```\r\n\r\n### When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions\r\n\r\n- Local class - Use it if you need to create more than one instance of a class, access its constructor, or introduce a new, named type (because, for example, you need to invoke additional methods later).\r\n- Anonymous class - Use it if you need to declare fields or additional methods.\r\n- Lambda expression or Method reference\r\n  - Use it if you are encapsulating a single unit of behavior that you want to pass to other code. For example, you would use a lambda expression if you want a certain action performed on each element of a collection, when a process is completed, or when a process encounters an error.\r\n  - Use it if you need a simple instance of a functional interface and none of the preceding criteria apply (for example, you do not need a constructor, a named type, fields, or additional methods).\r\n- Nested class\r\n\r\n  - Use it if your requirements are similar to those of a local class, you want to make the type more widely available, and you don't require access to local variables or method parameters.\r\n  - Use a non-static nested class (or inner class) if you require access to an enclosing instance's non-public fields and methods. Use a static nested class if you don't require this access.\r\n\r\n### Optional\r\n\r\n- `null` reference is the source of many problems because it is often used to denote the absence of a value\r\n- Java SE 8 introduces a new class called `java.util.Optional` that can alleviate some of these problems.\r\n- Thus, `Optional` object is a container object which may or may not contain a non-null value.\r\n- If a value is present, `isPresent()` will return true and `get()` will return the value.\r\n\r\n#### How to create Optional objects?\r\n\r\n- Empty Optional\r\n\r\n  ```java\r\n  Optional<String> msgOptional = Optional.empty();\r\n  ```\r\n\r\n- Optional with non-null value\r\n\r\n  ```java\r\n  String message = “Welcome to Java 8!”;\r\n  Optional<String> msgOptional = Optional.of(message);\r\n  ```\r\n\r\n  If `message` were `null`, a `NullPointerException` would immediately be thrown, rather than getting a latent error once you try to access properties of the `message` String object.\r\n\r\n- Optional object that may hold a null value\r\n\r\n  ```java\r\n  String message = null;\r\n  Optional<String> msgOptional = Optional.ofNullable(message);\r\n  ```\r\n\r\nIf `message` were `null`, the resulting `Optional` object would be empty (`Optional.empty()`) and would not throw `NullPointerException`.\r\n\r\n#### Check Value Presence and Do Action\r\n\r\n- `isPresent()`\r\n\r\n  - Returns `true` if the wrapped value is not `null`\r\n\r\n    ```java\r\n    Optional<String> msgOptional = …;\r\n    if (msgOptional.isPresent()) {\r\n      System.out.println(msgOptional.get());\r\n    }\r\n    ```\r\n\r\n    Before `Optional`, we would do:\r\n\r\n    ```java\r\n    String message = …;\r\n    if (message != null) {\r\n      System.out.println(message);\r\n    }\r\n    ```\r\n\r\n- `ifPresent()`\r\n\r\n  - Allows to run some codes if it returns `true`; takes a `Consumer` function which takes the object being checked as an argument.\r\n\r\n    ```java\r\n    Optional<String> msgOptional = …;\r\n    msgOptional.ifPresent(m -> System.out.println(m));\r\n    ```\r\n\r\n    Or\r\n\r\n    ```java\r\n    msgOptional.ifPresent(System.out::println);\r\n    ```\r\n\r\n- `orElse()`\r\n\r\n  - Retrieves value wrapped inside an `Optional` object if it is present and its argument otherwise.\r\n\r\n    ```java\r\n    Optional<String> msgOptional = …;\r\n    String message = msgOptional.orElse(“Welcome!”);\r\n    ```\r\n\r\n    Before `Optional`, we would do:\r\n\r\n    ```java\r\n    String message = …;\r\n    String msg = message != null ? Message : “Welcome!”;\r\n    ```\r\n\r\n- `orElseGet()`\r\n\r\n  - Similar to `orElse()`, it retrieves value wrapped inside an `Optional` object if it is present and its argument otherwise, however, it takes its default value from a `Supplier` which is invoked and returns the value of invocation.\r\n\r\n    ```java\r\n    Optional<String> msgOptional = …;\r\n    String message = msgOptional.orElseGet(() -> “Welcome!”);\r\n    ```\r\n\r\n- `orElseThrow()`\r\n\r\n  - Similar to `orElse()` and `orElseGet()`, it retrieves value wrapped inside an `Optional` object if it is present and its argument otherwise. Instead of returning a default value when wrapped value is not present, it throws an exception.\r\n\r\n    ```java\r\n    Optional<String> messageOptional = …;\r\n    String message = messageOptional.orElseThrow(() -> new IllegalArgumentException());\r\n    ```\r\n\r\n    Or\r\n\r\n    ```java\r\n    Optional<String> messageOptional = …;\r\n    String message = messageOptional.orElseThrow(IllegalArgumentException::new);\r\n    ```\r\n\r\n- `get()`\r\n\r\n  - Can only return value if it is present, otherwise, it returns `NoSuchElementException`.\r\n\r\n    ```java\r\n    Optional<String> messageOptional = …;\r\n    String message = messageOptional.get();\r\n    ```\r\n\r\n    Make sure to be defensive against possible `NoSuchElementException` when using this method:\r\n\r\n    ```java\r\n    String message = messageOptional.isPresent() ? messageOptional.get() : “Welcome!”;\r\n    ```\r\n\r\n- `filter()`\r\n\r\n  - If a value is present, and the value matches the given predicate, return an `Optional` describing the value, otherwise return an empty `Optional`.\r\n\r\n    Example\r\n\r\n    ```java\r\n    Optional<String> answerOptional = Optional.of(“YES”)\r\n        .filter(b -> b.equalsIgnorecase(“yes”));\r\n    ```\r\n\r\n  - If a value is present, and the value matches the given predicate, return an `Optional` describing the value, otherwise return an empty `Optional`.\r\n\r\n    Example\r\n\r\n    ```java\r\n    LocalDate birthday = LocalDate.of(2000, 7, 23);\r\n    Optional<LocalDate> legalAgeOptional1 = Optional.of(birthday)\r\n        .filter(this::isLegalAge);\r\n    ```\r\n\r\n    ```java\r\n    public boolean isLegalAge(LocalDate birthday) {\r\n      LocalDate currentDate = LocalDate.now(); // 2019-5-24\r\n      Period interval = Period.between(birthday, currentDate);\r\n\r\n      return interval.getYears() > 17;\r\n    }\r\n    ```\r\n\r\n    Above code will return `Optional` with a LocalDate value since filter meets the predicate.\r\n\r\n- `map()`\r\n\r\n  - Transforms value - if a value is present, apply the provided mapping function to it, and if the result is non-null, return an `Optional` describing the result. Otherwise return an empty `Optional`.\r\n\r\n    Example 1\r\n\r\n    ```java\r\n    List<String> frameworks = Arrays.asList(\"Spring\", “Spring Fu”, \"Quarkus\", \"Micronaut\", \"Play\", \"Struts\", \"Spark\", \"Summer Fun\");\r\n    Optional<List<String>> listOptional = Optional.of(frameworks);\r\n    int size = listOptional\r\n        .map(List::size) // Lambda expression .map(list -> list.size())\r\n        .orElse(0);\r\n    ```\r\n\r\n    Above code will return an integer value since mapping function is to get the size of `List`.\r\n\r\n    Example 2\r\n\r\n    ```java\r\n    class Person {\r\n      public Optional<String> getName() {\r\n        return Optional.of(\"Digong\");\r\n      }\r\n    }\r\n    ```\r\n\r\n    ```java\r\n    Person person = new Person();\r\n    Optional<Person> personOptional = Optional.of(person);\r\n    Optional<Optional<String>> nameOptionalWrapper = personOptional.map(Person::getName);\r\n    Optional<String> nameOptional = nameOptionalWrapper.orElse(Optional.empty());\r\n    String name = nameOptional.orElse(\"\");\r\n    ```\r\n\r\n    With `.map()`, we still need to get `Optional` that wraps another `Optional` (line 3). Then, `.orElse()`, line 4, gets the `Optional` wrapped in `Optional`. Finally, the last `.orElse()` extracts the name value.\r\n\r\n- `flatMap()`\r\n\r\n  - If a value is present, apply the provided `Optional`-bearing mapping function to it, return that result, otherwise return an empty `Optional`. This method is similar to `map()`, but the provided mapper is one whose result is already an `Optional`, and if invoked, `flatMap()` does not wrap it with an additional `Optional`.\r\n\r\n    ```java\r\n    Person person = new Person();\r\n    Optional<Person> personOptional = Optional.of(person);\r\n    Optional<String> nameOptional = personOptional.flatMap(Person::getName);\r\n    // Lambda expression: personOptional.flatMap(p -> p.getName());\r\n    String name = nameOptional.orElse(\"\");\r\n    ```\r\n\r\n    `.flatMap()` already returns the `Optional` wrapped in another `Optional`. We have saved a single line.\r\n\r\n### Stream API\r\n\r\n- A sequence of elements supporting sequential and parallel aggregate operations.\r\n- Collections in Java 8 are extended so you can simply create streams either by calling `Collection.stream()` or `Collection.parallelStream()`\r\n- `Stream` operations are either **intermediate** or **terminal**\r\n  - **Intermediate operations** return the `Stream` itself so you can chain multiple method calls in a row\r\n    - `filter`\r\n    - `sorted`\r\n    - `map`\r\n  - **Terminal operations** return a result of a certain type\r\n    - `forEach`\r\n    - `allMatch`\r\n    - `findFirst`\r\n    - `count`\r\n    - `reduce`\r\n    - `collect`\r\n\r\n#### Stream - filter()\r\n\r\nReturns a stream consisting of the elements of this stream that match the given predicate.\r\n\r\nExample:\r\n\r\n```java\r\nList<String> frameworks = new ArrayList<>();\r\nframeworks.add(\"Spring\");\r\nframeworks.add(\"Spring Fu\");\r\nframeworks.add(\"Quarkus\");\r\nframeworks.add(\"Micronaut\");\r\nframeworks.add(\"Play\");\r\nframeworks.add(\"Struts\");\r\nframeworks.add(\"Spark\");\r\nframeworks.add(\"Summer Fun\");\r\n\r\nList<String> frameworks = frameworks();\r\nList<String> frameworksStartWithS = frameworks.stream()\r\n        .filter(framework -> framework.startsWith(\"S\"))\r\n        .collect(Collectors.toList());\r\n```\r\n\r\n#### Stream - sorted()\r\n\r\nReturns a stream consisting of the elements of this stream, sorted according to natural order.\r\n\r\nExample\r\n\r\n```java\r\nList<String> frameworks = frameworks();\r\nList<String> frameworksSorted = frameworks.stream()\r\n        .sorted()\r\n        .collect(Collectors.toList());\r\n\r\n// reversed\r\nList<String> frameworksReversed = frameworks.stream()\r\n        .sorted(Collections.reverseOrder())\r\n        .collect(Collectors.toList());\r\n```\r\n\r\n#### Stream - map()\r\n\r\nReturns a stream consisting of the results of applying the given function to the elements of this stream.\r\n\r\nExample\r\n\r\n```java\r\nList<String> frameworks = frameworks();\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nList<String> frameworksToUpperCase = frameworks.stream()\r\n        .map(framework -> framework.toUpperCase())\r\n        .collect(Collectors.toList());\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nList<String> frameworksToUpperCase = frameworks.stream()\r\n        .map(String::toUpperCase)\r\n        .collect(Collectors.toList());\r\n```\r\n\r\n#### Stream - forEach()\r\n\r\nReturns an iterator over elements.\r\n\r\nExample\r\n\r\n```java\r\nList<String> frameworks = frameworks();\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nframeworks.forEach(framework -> System.out.println(framework));\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nframeworks.forEach(System.out::println);\r\n```\r\n\r\n#### Stream - allMatch()\r\n\r\nReturns whether all elements of this stream match the provided predicate.\r\n\r\nExample\r\n\r\n```java\r\nList<String> frameworks = frameworks();\r\nboolean allMatched = frameworks.stream()\r\n        .allMatch(framework -> framework.split(\" \").length > 1);\r\n```\r\n\r\n#### Stream - findFirst()\r\n\r\nReturns whether all elements of this stream match the provided predicate.\r\n\r\nExample\r\n\r\n```java\r\nList<String> frameworks = frameworks();\r\nOptional<String> frameworkOptional = frameworks.stream()\r\n        .filter(framework -> framework.contains(\"Fund\"))\r\n        .findFirst();\r\n```\r\n\r\n#### Stream - count()\r\n\r\nReturns the count of elements in this stream.\r\n\r\nExample\r\n\r\n```java\r\nList<String> frameworks = frameworks();\r\nlong countAll = frameworks.stream()\r\n        .count();\r\nlong countStartsWithS = frameworks.stream()\r\n        .filter(framework -> framework.startsWith(\"S\"))\r\n        .count();\r\n```\r\n\r\n#### Stream - reduce()\r\n\r\nPerforms a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.\r\n\r\nExample\r\n\r\n```java\r\nInteger[] grades = {90, 85, 92, 98, 88, 93};\r\nOptional<Integer> totalOptional = Stream.of(grades)\r\n        .reduce((g1, g2) -> g1 + g2);\r\ntotalOptional.ifPresent(System.out::println);\r\n```\r\n\r\n#### Stream - collect()\r\n\r\nPerforms a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.\r\n\r\nExample 1\r\n\r\n```java\r\nInteger[] grades = {90, 85, 92, 98, 88, 93};\r\nList<Integer> gradeList = Stream.of(grades)\r\n        .filter(grade -> grade > 89)\r\n        .collect(Collectors.toList());\r\n```\r\n\r\nExample 2\r\n\r\n```java\r\nList<User> users = Arrays.asList(\r\nnew User(\"John\", \"ADMIN\"),\r\nnew User(\"Luke\", \"USER\"),\r\nnew User(\"Matthew\", \"USER\"),\r\nnew User(\"Mark\", \"USER\"),\r\nnew User(\"Paul\", \"ADMIN\"));\r\n\r\nMap<String, User> userMap = users.stream()\r\n        .collect(Collectors.toMap(User::getRole, user -> user));\r\n```\r\n\r\n### New Date and Time API\r\n\r\n- The Date-Time APIs, introduced in JDK 8, are a set of packages that model the most important aspects of date and time\r\n- The core classes in the java.time package use the calendar system defined in **ISO-8601** (based on the Gregorian calendar system) as the default calendar.\r\n  - `java.time` - Classes for date, time, date and time combined, time zones, instants, duration, and clocks.\r\n  - `java.time.chrono` - API for representing calendar systems other than ISO-8601. Several predefined chronologies are provided and you can also define your own chronology.\r\n  - `java.time.format` - Classes for formatting and parsing dates and time.\r\n  - `java.time.temporal` - Extended API, primarily for framework and library writers, allowing interoperations between the date and time classes, querying, and adjustment. Fields and units are defined in this package.\r\n  - `java.time.zone` - Classes that support time zones, offsets from time zones, and time zone rules. on the Gregorian calendar system) as the default calendar.\r\n- Old Date API\r\n  - Existing classes aren’t thread-safe, leading to potential concurrency issues for users—not something the average developer would expect to deal with when writing date-handling code.\r\n  - Some of the date and time classes also exhibit quite poor API design. For example, years in `java.util.Date` start at 1900, months start at 1, and days start at 0—not very intuitive.\r\n  - These issues, and several others, have led to the popularity of third-party date and time libraries, such as Joda-Time.\r\n\r\nThe project, **Date and Time API**, has been led jointly by the author of **Joda-Time** (**Stephen Colebourne**) and Oracle, under **JSR 310**, and appears in the new Java SE 8 package `java.time`.\r\n\r\n#### New Date and Time API - Clock\r\n\r\n**Clock**\r\n\r\n- A clock providing access to the current instant, date and time using a time-zone.\r\n\r\nExample\r\n\r\n```java\r\nClock clock = Clock.systemDefaultZone();\r\nlong millis = clock.millis();\r\n\r\nInstant instant = clock.instant();\r\nDate legacyDate = Date.from(instant);\r\n```\r\n\r\n#### New Date and Time API - Timezone\r\n\r\n**ZoneId**\r\n\r\n- A time-zone ID, such as `Asia/Manila`. A `ZoneId` is used to identify the rules used to convert between, an `Instant` and a `LocalDateTime`.\r\n\r\nExample\r\n\r\n```java\r\nSet<ZoneId> availableZoneIds = ZoneId.getAvailableZoneIds();\r\n```\r\n\r\n```java\r\nZoneId zone1 = ZoneId.of(\"Asia/Manila\");\r\nZoneId zone2 = ZoneId.of(\"Europe/Paris\");\r\nSystem.out.println(zone1.getRules());   // ZoneRules[currentStandardOffset=+08:00]\r\nSystem.out.println(zone2.getRules());   // ZoneRules[currentStandardOffset=+01:00]\r\n```\r\n\r\n#### New Date and Time API - LocalTime\r\n\r\n**LocalTime**\r\n\r\n- A time without a time-zone in the ISO-8601 calendar system, such as `08:24:15`.\r\n\r\nExample\r\n\r\n```java\r\nZoneId zone1 = ZoneId.of(\"Asia/Manila\");\r\nZoneId zone2 = ZoneId.of(\"Europe/Paris\");\r\nLocalTime now1 = LocalTime.now(zone1);\r\nLocalTime now2 = LocalTime.now(zone2);\r\n\r\nSystem.out.println(now1.isBefore(now2));  // false\r\n\r\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\r\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\r\n\r\nSystem.out.println(hoursBetween);       // -6\r\nSystem.out.println(minutesBetween);     // -360\r\n```\r\n\r\n#### New Date and Time API - LocalDate\r\n\r\n**LocalDate**\r\n\r\n- A date without a time-zone in the ISO-8601 calendar system, such as `2019-05-24`.\r\n\r\nExample\r\n\r\n```java\r\nLocalDate today = LocalDate.now();\r\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\r\nLocalDate yesterday = tomorrow.minusDays(2);\r\n\r\nLocalDate independenceDay = LocalDate.of(2019, Month.MAY, 24);\r\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\r\nSystem.out.println(dayOfWeek);    // FRIDAY\r\n```\r\n\r\n#### New Date and Time API - LocalDateTime\r\n\r\n**LocalDateTime**\r\n\r\n- A date-time without a time-zone in the ISO-8601 calendar system, such as `2019-05-24T08:24:15`.\r\n\r\nExample\r\n\r\n```java\r\nLocalDateTime ldt = LocalDateTime.of(2019, Month.MAY, 24, 14, 55, 59);\r\n\r\nDayOfWeek dayOfWeek = ldt.getDayOfWeek();\r\nSystem.out.println(dayOfWeek);      // FRIDAY\r\n\r\nMonth month = ldt.getMonth();\r\nSystem.out.println(month);          // MAY\r\n\r\nlong minuteOfDay = ldt.getLong(ChronoField.MINUTE_OF_DAY);\r\nSystem.out.println(minuteOfDay);    // 895\r\n```\r\n\r\n---\r\n\r\n# References\r\n\r\n1. https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8\r\n2. https://www.tutorialspoint.com/java8/index.htm\r\n3. https://winterbe.com/posts/2014/03/16/java-8-tutorial/\r\n4. https://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html\r\n5. https://www.baeldung.com/java-optional\r\n6. https://www.baeldung.com/java-8-streams\r\n7. https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html\r\n"}},"__N_SSG":true}