---
layout: post
title: Java 8 New Language Features
date: 2019-07-06
description: This post discusses the new features introduced to Java 8 language.
keywords: java, java 8, lambda, functional, optional
---

<h3>Overview</h3>
<p>This post discusses the new language features of Java 8. Java 8's release is the most awaited and is a major feature
    release of Java programming language.</p>
<p>These new features include <span class="font-weight-bold">functional interfaces</span>, <span
        class="font-weight-bold">interface default method</span>, <span class="font-weight-bold">lambda
        expressions</span>, <span class="font-weight-bold">method references</span>,
    <span class="font-weight-bold">Optional</span>, and <span class="font-weight-bold">Stream API</span>. We will also
    talk about some of <span class="font-weight-bold">built-in functions</span> that implement Function Interface and
    the <span class="font-weight-bold">New Date and Time API</span>.</p>
<h3>Functional Interface</h3>
<p>Functional Interface is an interface with <span class="font-weight-bold">single abstract method (SAM)</span>. Static
    or the new default method is not
    counted. To indicate that an interface is a Functional Interface, annotation <span
        class="inline-code">@FunctionalInterface</span> on class level is
    needed. While an interface with SAM could still function as Functional Interface (qualified as lambda expression)
    even if it does not have such
    annotation (example is AWT's <span class="inline-code">ActionListener</span>), it is recommened that it be
    annotated.</p>
<p>Some old built-in interfaces with SAM, such as <span class="inline-code">Comparator</span> and <span
        class="inline-code">Runnable</span>, have been annotated with <span
        class="inline-code">@FunctionalInterface</span>
    and can be used as lambda expressions</p>
<h4>Example</h4>
<script type="text/plain" class="language-java">
    @FunctionalInterface
	public interface Calculator {
	    long calculate(long x, long y);
	}
</script>
<p>We can implement above interface in two ways prior to Java 8.</p>
<ul>
    <li>Anonymous class
        <script type="text/plain" class="language-java">
            Calculator division = new Calculator() {
                @Override
                 public long calculate(long x, long y) {
                    return x / y;
                 }
            };
        
            long quotient = division.calculate(10, 2);
        </script>
    </li>
    <li>Concrete class
        <script type="text/plain" class="language-java">
            class Division implements Calculator {
                @Override
                public long calculate(long x, long y) {
                    return x / y;
                }
            }
        </script>
        <script type="text/plain" class="language-java">
            Calculator division = new Division() ;
            long quotient = division.calculate(10, 2);
        </script>
    </li>
</ul>
<p>With Java 8, there is a third way to to implement an interface and that is by using <span
        class="font-weight-bold">Lambda Expressions</span></p>
<h3>Lambda Expressions</h3>
<p>Lambda expressions encapsulate a single unit of behavior and pass it to other code. To be able to create lambda
    expression, you need first a Funtional Interface. This is the reason why a
    Functional Interface has a single abstract method. Instead of an anonymous class, you can use lambda expression
    which is a concise alternative and shorthand replacement for it.</p>
<h4>Syntax</h4>
<script type="text/plain" class="language-java">
    parameter -> expression or statement body
</script>
<h4>Example</h4>
<script type="text/plain" class="language-java">
    (Integer x) -> { return x; };
</script>
<h4>Characteristics of Lambda Expression</h4>
<ol>
    <li>Optional type declaration<br>
        <script type="text/plain" class="language-java">
            (x) -> { return x; };
        </script>
    </li>
    <li>Optional parentheses<br>
        <script type="text/plain" class="language-java">
            x -> { return x; };
        </script>
        <p>Parentheses are required if there are multiple parameters. Parameters are separated by comma (<span
                class="inline-code">,</span>).</p>
        <script type="text/plain" class="language-java">
            (x, y) -> { return x + y; };
        </script>
    </li>
    <li>Optional curly braces (<span class="inline-code">{}</span>) and optional <span class="inline-code">return</span>
        keyword<br>
        <script type="text/plain" class="language-java">
            x -> x;
        </script>
        <p>Curly braces are required if body has multiple statements. <span class="inline-code">return</span> keyword is
            required for a function with
            return value if body has multiple statements. No <span class="inline-code">return</span> keyword is required
            if function does not return a
            value as in regular method.</p>
        <script type="text/plain" class="language-java">
                x -> {
                    System.out.println("Hello world!");
                    return x;
                };
            </script>
        <script type="text/plain" class="language-java">
                x -> {
                    System.out.println("Hello world!");
                    System.out.println("Welcome to Java 8 Programming!");
                };
            </script>
    </li>
</ol>
<p>Remember our <span class="inline-code">Calculator</span> interface? Here is how implement it using lambda expression:
</p>
<script type="text/plain" class="language-java">
    Calculator multiplication = (a, b) -> a * b;    // or (a, b) -> Math.multiplyExact(a, b);
    Calculator division = (a, b) -> a / b;
    Calculator addition = (a, b) -> a + b;          // or (a, b) -> Math.addExact(a, b);
    Calculator subtraction = (a, b) -> a - b;       // or (a, b) -> Math.subtractExact(a, b);

    long product = multiplication.calculate(5, 5);
    long quotient = division.calculate(10, 2);
    long sum = addition.calculate(5, 5);
    long difference = subtraction.calculate(10, 4);
</script>
<h3 id="built-in-functions">Built-in Functions</h3>
<p>Java 8 ships 43 built-in functions under <span class="inline-code">java.util.function</span> package. Thirty eight
    (38) of them are specialization for
    primitive and other functions.</p>
<p>The following are the basic functions:</p>
<ul>
    <li><span class="inline-code">Function</span></li>
    <li><span class="inline-code">Consumer</span></li>
    <li><span class="inline-code">Supplier</span></li>
    <li><span class="inline-code">Predicate</span></li>
</ul>
<h4>Function</h4>
<p>Function represents a function that accepts one argument and produces a result. The type parameter T represents
    the type of the input to the function while the second one R represents the type of result. The functonal method of
    this functional interface is <span class="inline-code">apply(Object)</span>.</p>
<script type="text/plain" class="language-java">
    @FunctionalInterface
    public interface Function<T,R>
</script>
<h5>Examples</h5>
<p>Below is an example of Function that accepts a String argument and returns a String.</p>
<script type="text/plain" class="language-java">
    Function<String, String> f1 = a -> a;
    String message = f1.apply("Welcome to Java 8!");
</script>
<p>This one accepts a String argument and returns an integer.</p>
<script type="text/plain" class="language-java">
    Function<String, Integer> f2 = a -> a.length();
    int textLength = f2.apply("Welcome to Java 8!");
</script>
<h4>Consumer</h4>
<p>Consumer represents an operation that accepts a single input argument and returns no result. The type parameter T
    represents the type of the input to the operation. The functonal method of this functional interface is <span
        class="inline-code">accept(Object)</span>.</p>
<script type="text/plain" class="language-java">
    @FunctionalInterface
    public interface Consumer<T>
</script>
<h5>Examples</h5>
<p>Both accept String input argument and returns no value.</p>
<script type="text/plain" class="language-java">
    Consumer<String> c1 = a -> System.out.println(a);
    c1.accept("Welcome to Java 8!");
    
    Consumer<String> c2 = a -> {
        String message = "Welcome to " + a + "!";
        System.out.println(message);
    };    
    c2.accept("Java 8");
</script>
<h4>Supplier</h4>
<p>Supplier Represents a supplier of results. The type parameter T represents the type of results supplied by the
    supplier. This is a functional interface whose functional method is <span class="inline-code">get()</span>.</p>
<script type="text/plain" class="language-java">
    @FunctionalInterface
    public interface Supplier<T>
</script>
<h5>Examples</h5>
<p>This example returns a value of String type.</p>
<script type="text/plain" class="language-java">
    Supplier<String> stringSupplier = () -> "Welcome to Java 8!";
    String message = stringSupplier.get();
</script>
<p>And this one returns a value of User type.</p>
<script type="text/plain" class="language-java">
    Supplier<User> userSupplier = () -> new User();
    User user = userSupplier.get();
</script>
<h4>Predicate</h4>
<p>Predicate represents a predicate (boolean-valued function) of one argument. The type parameter T represents the type
    of the input to the predicate. This is a functional interface whose functional method is <span
        class="inline-code">test(Object)</span>.</p>
<script type="text/plain" class="language-java">
    @FunctionalInterface
    public interface Predicate<T>    
</script>
<h5>Examples</h5>
<p>To check if argument is equal to "YES" regardless of case:</p>
<script type="text/plain" class="language-java">
    Predicate<String> answerPredicate = a -> "YES".equalsIgnoreCase(a);
    boolean isYes = answerPredicate.test("Yes");
</script>
<p>To check if person is of legal age (18 and above):</p>
<script type="text/plain" class="language-java">
    public static Predicate<Integer> isLegalAge() {
        return age -> age >= 18;
    }
</script>
<script type="text/plain" class="language-java">
    boolean legalAge = isLegalAge().test(18);
</script>
<h4>Built-in Functions - Specialization</h4>
<p>Other built-in functions are specializations for primitive types and for basic or another specialization functions.
</p>
<p>To check all other built-in functions, please visit this <a
        href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html"
        target="blank">Javadoc</a>.</p>
<h4>Existing Interface - Comparator</h4>
<p><span class="inline-code">Comparator</span> is an existing interface in Java since version 1.2. This interface has a
    single abstract method, <span class="inline-code">compare(T o1, T o2)</span>, and, therefore, can be used as lambda
    expression similar to functions added to Java 8.</p>
<p>Prior to Java 8, we would use <span class="inline-code">Comparator</span> in sorting a collection the following way:
</p>
<script type="text/plain" class="language-java">
    List<String> choices = Arrays.asList("c", "a", "d", "b", "e");

    Collections.sort(choices, new Comparator<String>() {
        @Override
        public int compare(String a, String b) {
            return a.compareTo(b);
        }
    });
</script>
<p>With Java 8:</p>
<script type="text/plain" class="language-java">
    Comparator<String> comparator = (a, b) -> a.compareTo(b);
    Collections.sort(choices, comparator);
</script>
<script type="text/plain" class="language-java">
    Collections.sort(choices, (String a, String b) -> {
        return a.compareTo(b);
    });
</script>
<script type="text/plain" class="language-java">
    Collections.sort(choices, (String a, String b) -> a.compareTo(b));
</script>
<script type="text/plain" class="language-java">
    Collections.sort(choices, (a, b) -> a.compareTo(b));
</script>
<h3>Default Methods</h3>
<p>Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary
    compatibility with code written for older versions of those interfaces. They are interface methods that have an
    implementation, similar to static methods, and the <span class="inline-code">default</span> keyword at the beginning
    of the method signature.
</p>
<h4>Syntax</h4>
<script type="text/plain" class="language-java">
    default type methodName(type parameter) {
		body
	}
</script>
<p>For example, default method <span class="inline-code">forEach()</span> was added to <span
        class="inline-code">Iterable</span> interface. This method takes a <span class="inline-code">Consumer</span>
    argument
    and performs action for each element (similar to enhanced <span class="inline-code">for-each</span> construct).
    <span class="inline-code">List</span> interface which extends <span class="inline-code">Iterable</span>
    can now be used with <span class="inline-code">forEach()</span> method:</p>
<script type="text/plain" class="language-java">
    List<String> days = Arrays.asList("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday");
    days.forEach(day -> System.out.println(day));    
</script>
<h4>Example</h4>
<script type="text/plain" class="language-java">
    public interface Calculator {
        double calculate(double number);
        
        default double sqrt(double number) {
            return Math.sqrt(number);
        }
    }
</script>
<script type="text/plain" class="language-java">
    Calculator sc = x -> x * x;
    double square = sc.calculate(10.0); // 100.0
    double sqrt = sc.sqrt(square);      // 10.0
</script>
<h3>Method References</h3>
<p>Java 8 enables you to pass references of methods or constructors via the :: keyword. Method references are compact,
    easy-to-read lambda expressions for methods that already have a name. They are
    Preferred over lambda expression if the expression does nothing but calls an existing method.</p>
<h4>Syntax</h4>
<script type="text/plain" class="language-java">
    Reference::methodName
</script>
<h4>Types of Method References</h4>
<table class="table table-bordered table-striped">
    <thead>
        <tr>
            <th scope="col">Type</th>
            <th scope="col">Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th scope="row">Reference to a static method</th>
            <td>ContainingClass::staticMethodName</td>
        </tr>
        <tr>
            <th scope="row">Reference to an instance method of a particular object</th>
            <td>containingObject::instanceMethodName</td>
        </tr>
        <tr>
            <th scope="row">Reference to an instance method of an arbitrary object of a particular type</th>
            <td>ContainingType::methodName</td>
        </tr>
        <tr>
            <th scope="row">Reference to a constructor</th>
            <td>ClassName::new</td>
        </tr>
    </tbody>
</table>
<p>To be continued...</p>