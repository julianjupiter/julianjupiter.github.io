<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="author" content="Julian Jupiter"/><meta name="description" content="This post discusses the new features introduced to Java 8 language."/><meta name="keywords" content=""/><title>Julian Jupiter - Blog - Java 8 New Language Features</title><link rel="shortcut icon" href="/assets/images/favicon.PNG"/><link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300&amp;display=swap" rel="stylesheet"/><link href="/assets/vendor/prismjs/themes/prism-tomorrow.css" rel="stylesheet"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/bfc8cab2af74749035f1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/bfc8cab2af74749035f1.css"/><link rel="preload" href="/_next/static/ywGPERTp6BisonP7U8tUh/pages/blog/%5Bslug%5D.js" as="script"/><link rel="preload" href="/_next/static/ywGPERTp6BisonP7U8tUh/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-b65cab0b00afd201cbda.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.4503cc20512dbab0b6d3.js" as="script"/><link rel="preload" href="/_next/static/chunks/07fdf76e751aca78a46eb975a54a24e4b4193c25.627b6b3615d0d2a4c6c1.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-11312f39460057087083.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9a7754c.29c45f57a1035e7b8fe9.js" as="script"/><link rel="preload" href="/_next/static/chunks/100a3ba0b69c26a511790651df7de2bbf06df0e5.0b49a536fe8cdc6d5399.js" as="script"/></head><body><div id="__next"><header><nav class="navbar navbar-expand-lg navbar-light fixed-top bg-white"><div class="container"><a class="navbar-brand" href="/"><img src="/assets/images/logo.png" alt="Julian Jupiter&#x27;s logo" class="icon icon-lg" style="height:45px;border:4px solid #fff;border-radius:50%"/> <!-- -->Julian Jupiter</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="#">Profile</a></li><li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li><li class="nav-item"><a class="nav-link" href="/projects">Projects</a></li></ul></div></div></nav></header><main role="main"><header><nav class="navbar navbar-expand-lg navbar-light fixed-top bg-white"><div class="container"><a class="navbar-brand" href="/"><img src="/assets/images/logo.png" alt="Julian Jupiter&#x27;s logo" class="icon icon-lg" style="height:45px;border:4px solid #fff;border-radius:50%"/> <!-- -->Julian Jupiter</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="#">Profile</a></li><li class="nav-item active"><a class="nav-link" href="/blog">Blog<!-- --> <span class="sr-only">(current)</span></a></li><li class="nav-item"><a class="nav-link" href="/projects">Projects</a></li></ul></div></div></nav></header><section class="jumbotron text-center mb-0 rouded-0"><div class="container"><h1 class="jumbotron-heading font-weight-bold text-deep-orange">Java 8 New Language Features</h1><p class="lead text-muted mb-0"><info dateTime="2019-07-06">July 6, 2019</info> | <a data-disqus-identifier="/blog/java-8-new-language-features" href="https://julianjupiter.com/blog/java-8-new-language-features.html#disqus_thread"></a></p></div></section><section class="bg-white" style="padding:4rem 2rem"><div class="container"><div class="row justify-content-center"><div class="col text-justify" style="font-size:1.25rem"><h3>Overview</h3><p>This post discusses the new language features of <strong>Java 8</strong>. Java 8&#x27;s release is the most awaited and is a major feature release of Java programming language.</p><p>These new features include <strong>functional interfaces</strong>, <strong>interface default method</strong>, <strong>lambda expressions</strong>, <strong>method references</strong>, <strong>Optional</strong>, and <strong>Stream API</strong>. We will also talk about some of <strong>built-in functions</strong> that implement Function Interface and the <strong>New Date and Time API</strong>.</p><h3>Functional Interface</h3><p>Functional Interface is an interface with <strong>single abstract method (SAM)</strong>. Static or the new default method is not counted. To indicate that an interface is a <strong>Functional Interface</strong>, annotation <code>@FunctionalInterface</code> on class level is needed. While an interface with SAM could still function as <strong>Functional Interface</strong> (qualified as lambda expression) even if it does not have such annotation (example is AWT&#x27;s <code>ActionListener</code>), it is recommended that it be annotated.</p><p>Some old built-in interfaces with SAM, such as <code>Comparator</code> and <code>Runnable</code>, have been annotated with <code>@FunctionalInterface</code> and can be used as lambda expressions.</p><h4>Example</h4><pre><code class="language-java">@FunctionalInterface
public interface Calculator {
  long calculate(long x, long y);
}</code></pre><p>We can implement above interface in two ways prior to Java 8.</p><ul><li><p>Anonymous class</p><pre><code class="language-java">Calculator division = new Calculator() {
  @Override
  public long calculate(long x, long y) {
    return x / y;
  }
};

long quotient = division.calculate(10, 2);</code></pre></li><li><p>Concrete class</p><pre><code class="language-java">class Division implements Calculator {
  @Override
    public long calculate(long x, long y) {
    return x / y;
  }
}</code></pre><pre><code class="language-java">Calculator division = new Division() ;
long quotient = division.calculate(10, 2);</code></pre></li></ul><p>With Java 8, there is a third way to to implement an interface and that is by using <strong>Lambda Expressions</strong>.</p><h3>Lambda Expressions</h3><p>Lambda expressions encapsulate a single unit of behavior and pass it to other code. To be able to create lambda expression, you need first a Funtional Interface. This is the reason why a Functional Interface has a single abstract method. Instead of an anonymous class, you can use lambda expression which is a concise alternative and shorthand replacement for it.</p><h4>Syntax</h4><pre><code class="language-java">parameter -&gt; expression or statement body</code></pre><h4>Example</h4><pre><code class="language-java">(Integer x) -&gt; { return x; };</code></pre><h4>Characteristics of Lambda Expression</h4><ol><li>Optional type declaration</li></ol><pre><code class="language-java">(x) -&gt; { return x; };</code></pre><ol start="2"><li>Optional parentheses<br/></li></ol><pre><code class="language-java">x -&gt; { return x; };</code></pre><p>Parentheses are required if there are multiple parameters. Parameters are separated by comma (<code>,</code>).</p><pre><code class="language-java">(x, y) -&gt; { return x + y; };</code></pre><ol start="3"><li>Optional curly braces (<code>{}</code>) and optional <code>return</code> keyword</li></ol><pre><code class="language-java">x -&gt; x;</code></pre><p>Curly braces are required if body has multiple statements. <code>return</code> keyword is required for a function with return value if body has multiple statements. No <code>return</code> keyword is required if function does not return a value as in regular method.</p><pre><code class="language-java">x -&gt; {
  System.out.println(&quot;Hello world!&quot;);
  return x;
};</code></pre><pre><code class="language-java">x -&gt; {
  System.out.println(&quot;Hello world!&quot;);
  System.out.println(&quot;Welcome to Java 8 Programming!&quot;);
};</code></pre><p>Remember our <code>Calculator</code> interface? Here is how to implement it using lambda expression:</p><pre><code class="language-java">Calculator multiplication = (a, b) -&gt; a * b;    // or (a, b) -&gt; Math.multiplyExact(a, b);
Calculator division = (a, b) -&gt; a / b;
Calculator addition = (a, b) -&gt; a + b;          // or (a, b) -&gt; Math.addExact(a, b);
Calculator subtraction = (a, b) -&gt; a - b;       // or (a, b) -&gt; Math.subtractExact(a, b);

long product = multiplication.calculate(5, 5);
long quotient = division.calculate(10, 2);
long sum = addition.calculate(5, 5);
long difference = subtraction.calculate(10, 4);</code></pre><h3>Built-in Functions</h3><p>Java 8 ships 43 built-in functions under <code>java.util.function</code> package. <strong>Thirty eight</strong> (<strong>38</strong>) of them are specialization for primitive and other functions.</p><p>The following are the basic functions:</p><ol><li><code>Function</code></li><li><code>Consumer</code></li><li><code>Supplier</code></li><li><code>Predicate</code></li></ol><h4>Function</h4><p>Function represents a function that accepts one argument and produces a result. The type parameter <code>T</code> represents the type of the input to the function while the second one R represents the type of result. The functonal method of this functional interface is <code>apply(Object)</code>.</p><pre><code class="language-java">@FunctionalInterface
public interface Function&lt;T,R&gt;</code></pre><h5>Examples</h5><p>Below is an example of Function that accepts a String argument and returns a String.</p><pre><code class="language-java">Function&lt;String, String&gt; f1 = a -&gt; a;
String message = f1.apply(&quot;Welcome to Java 8!&quot;);</code></pre><p>This one accepts a String argument and returns an integer.</p><pre><code class="language-java">Function&lt;String, Integer&gt; f2 = a -&gt; a.length();
int textLength = f2.apply(&quot;Welcome to Java 8!&quot;);</code></pre><h4>Consumer</h4><p>Consumer represents an operation that accepts a single input argument and returns no result. The type parameter <code>T</code> represents the type of the input to the operation. The functonal method of this functional interface is <code>accept(Object)</code>.</p><pre><code class="language-java">@FunctionalInterface
public interface Consumer&lt;T&gt;</code></pre><h5>Examples</h5><p>Both accept String input argument and returns no value.</p><pre><code class="language-java">Consumer&lt;String&gt; c1 = a -&gt; System.out.println(a);
c1.accept(&quot;Welcome to Java 8!&quot;);

Consumer&lt;String&gt; c2 = a -&gt; {
  String message = &quot;Welcome to &quot; + a + &quot;!&quot;;
  System.out.println(message);
};
c2.accept(&quot;Java 8&quot;);</code></pre><h4>Supplier</h4><p>Supplier Represents a supplier of results. The type parameter <code>T</code> represents the type of results supplied by the supplier. This is a functional interface whose functional method is <code>get()</code>.</p><pre><code class="language-java">@FunctionalInterface
public interface Supplier&lt;T&gt;</code></pre><h5>Examples</h5><p>This example returns a value of String type.</p><pre><code class="language-java">Supplier&lt;String&gt; stringSupplier = () -&gt; &quot;Welcome to Java 8!&quot;;
String message = stringSupplier.get();</code></pre><p>And this one returns a value of User type.</p><pre><code class="language-java">Supplier&lt;User&gt; userSupplier = () -&gt; new User();
User user = userSupplier.get();</code></pre><h4>Predicate</h4><p>Predicate represents a predicate (boolean-valued function) of one argument. The type parameter <code>T</code> represents the type of the input to the predicate. This is a functional interface whose functional method is <code>test(Object)</code>.</p><pre><code class="language-java">@FunctionalInterface
public interface Predicate&lt;T&gt;</code></pre><h5>Examples</h5><p>To check if argument is equal to &quot;YES&quot; regardless of case:</p><pre><code class="language-java">Predicate&lt;String&gt; answerPredicate = a -&gt; &quot;YES&quot;.equalsIgnoreCase(a);
boolean isYes = answerPredicate.test(&quot;Yes&quot;);</code></pre><p>To check if person is of legal age (18 and above):</p><pre><code class="language-java">public static Predicate&lt;Integer&gt; isLegalAge() {
  return age -&gt; age &gt;= 18;
}</code></pre><pre><code class="language-java">boolean legalAge = isLegalAge().test(18);</code></pre><h4>Built-in Functions - Specialization</h4><p>Other built-in functions are specializations for primitive types and for basic or another specialization functions.</p><p>To check all other built-in functions, please visit this <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="blank">Javadoc</a>.</p><h4>Existing Interface - Comparator</h4><p><code>Comparator</code> is an existing interface in Java since version 1.2. This interface has a single abstract method, <code>compare(T o1, T o2)</code>, and, therefore, can be used as lambda expression similar to functions added to Java 8.</p><p>Prior to Java 8, we would use <span class="inline-code">Comparator</span> in sorting a collection the following way:</p><pre><code class="language-java">List&lt;String&gt; choices = Arrays.asList(&quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;b&quot;, &quot;e&quot;);

Collections.sort(choices, new Comparator&lt;String&gt;() {
  @Override
  public int compare(String a, String b) {
    return a.compareTo(b);
  }
});</code></pre><p>With Java 8:</p><pre><code class="language-java">Comparator&lt;String&gt; comparator = (a, b) -&gt; a.compareTo(b);
Collections.sort(choices, comparator);</code></pre><pre><code class="language-java">Collections.sort(choices, (String a, String b) -&gt; {
  return a.compareTo(b);
});</code></pre><pre><code class="language-java">Collections.sort(choices, (String a, String b) -&gt; a.compareTo(b));</code></pre><pre><code class="language-java">Collections.sort(choices, (a, b) -&gt; a.compareTo(b));</code></pre><h3>Default Methods</h3><p>Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces. They are interface methods that have an implementation, similar to static methods, and the <code>default</code> keyword at the beginning of the method signature.</p><h4>Syntax</h4><pre><code class="language-java">default type methodName(type parameter) {
  body
}</code></pre><p>For example, default method <code>forEach()</code> was added to <code>Iterable</code> interface. This method takes a <code>Consumer</code> argument and performs action for each element (similar to enhanced <code>for-each</code> construct). <code>List</code> interface which extends <code>Iterable</code> can now be used with <code>forEach()</code> method:</p><pre><code class="language-java">List&lt;String&gt; days = Arrays.asList(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;);
days.forEach(day -&gt; System.out.println(day));</code></pre><h4>Example</h4><pre><code class="language-java">public interface Calculator {
  double calculate(double number);

  default double sqrt(double number) {
    return Math.sqrt(number);
  }
}</code></pre><pre><code class="language-java">Calculator sc = x -&gt; x * x;
double square = sc.calculate(10.0); // 100.0
double sqrt = sc.sqrt(square);      // 10.0</code></pre><h3>Method References</h3><p>Java 8 enables you to pass references of methods or constructors via the :: keyword. Method references are compact, easy-to-read lambda expressions for methods that already have a name. They are preferred over lambda expression if the expression does nothing but calls an existing method.</p><h4>Syntax</h4><pre><code class="language-java">Reference::methodName</code></pre><h4>Types of Method References</h4><table class="table table-bordered table-striped">
    <thead>
        <tr>
            <th scope="col">Type</th>
            <th scope="col">Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th scope="row">Reference to a static method</th>
            <td>ContainingClass::staticMethodName</td>
        </tr>
        <tr>
            <th scope="row">Reference to an instance method of a particular object</th>
            <td>containingObject::instanceMethodName</td>
        </tr>
        <tr>
            <th scope="row">Reference to an instance method of an arbitrary object of a particular type</th>
            <td>ContainingType::methodName</td>
        </tr>
        <tr>
            <th scope="row">Reference to a constructor</th>
            <td>ClassName::new</td>
        </tr>
    </tbody>
</table><h4>Example</h4><h5>Reference to a static method</h5><ol><li>Example 1</li></ol><pre><code class="language-java">class Person {
  private LocalDate birthday;

  public Person() {}

  public Person(LocalDate birthday) {
    this.birthday = birthday;
  }

  // setters, getters

  public static int compareByAge(Person a, Person b) {
    return a.birthday.compareTo(b.birthday);
  }
}</code></pre><pre><code class="language-java">Person p1 = new Person(LocalDate.of(2000, 6, 21));
Person p2 = new Person(LocalDate.of(2000, 6, 15));
Person p3 = new Person(LocalDate.of(1998, 3, 28));
Person[] persons = {p1, p2, p3};</code></pre><p>Lambda Expression</p><pre><code class="language-java">Arrays.sort(persons, (p1, p2) -&gt; Person.compareByAge(p1, p2));</code></pre><p>Method Reference</p><pre><code class="language-java">Arrays.sort(persons, Person::compareByAge);</code></pre><ol><li>Example 2</li></ol><pre><code class="language-java">@FunctionalInterface
public interface StringToIntConverter {
  int convert(String string);
}</code></pre><p>Lambda Expression</p><pre><code class="language-java">StringToIntConverter converter = s -&gt; Integer.valueOf(s);
int i = converter.convert(&quot;10&quot;);</code></pre><p>Method Reference</p><pre><code class="language-java">StringToIntConverter converter = Integer::valueOf;
int i = converter.convert(&quot;10&quot;);</code></pre><h5>Reference to an instance method of a particular object</h5><ol><li>Example 1</li></ol><pre><code class="language-java">public class Something {
  public int getYear(LocalDate localDate) {
    return localDate.getYear();
  }
}</code></pre><p>Lambda Expression</p><pre><code class="language-java">Something something = new Something();
Function&lt;LocalDate, Integer&gt; f = d -&gt; something.getYear(d);
int year = f.apply(p1.getBirthday());</code></pre><p>Method Reference</p><pre><code class="language-java">Something something = new Something();
Function&lt;LocalDate, Integer&gt; f = something::getYear;
int year = f.apply(p1.getBirthday());</code></pre><ol start="2"><li>Example 2</li></ol><pre><code class="language-java">public interface PersonDao {
  Person findById(int id);
}</code></pre><p>Lambda Expression</p><pre><code class="language-java">PersonDao personDao = new PersonDaoImpl();
Function&lt;Integer, Person&gt; f = id -&gt; personDao.findById(id);
Person person = f.apply(1);</code></pre><p>Method Reference</p><pre><code class="language-java">PersonDao personDao = new PersonDaoImpl();
Function&lt;Integer, Person &gt; f = personDao::findById;
Person person = f.apply(1);</code></pre><h5>Reference to an instance method of an arbitrary object of a particular type</h5><ol><li>Example 1</li></ol><p>Lambda Expression</p><pre><code class="language-java">Function&lt;String, String&gt; f = s -&gt; s.toUpperCase();
String httpGet = f.apply(&quot;get&quot;);</code></pre><p>Method Reference</p><pre><code class="language-java">Function&lt;String, String&gt; f = String::toUpperCase;
String httpGet = f.apply(&quot;get&quot;);</code></pre><ol start="2"><li>Example 2</li></ol><p>Lambda Expression</p><pre><code class="language-java">Person person = ...
Function&lt;Person, LocalDate&gt; f = p -&gt; p.getBirthday();
LocalDate birthday = f.apply(person);</code></pre><p>Method Reference</p><pre><code class="language-java">Person person = ...
Function&lt;Person, LocalDate&gt; f = Person::getBirthday;
LocalDate birthday = f.apply(person);</code></pre><h5>Reference to a constructor</h5><ol><li>Example 1</li></ol><p>Lambda Expression</p><pre><code class="language-java">Function&lt;LocalDate, Person&gt; f = d -&gt; new Person(d);
LocalDate birthday = LocalDate.of(2000, 10, 12);
Person person = f.apply(birthday);</code></pre><p>Method Reference</p><pre><code class="language-java">Function&lt;LocalDate, Person&gt; f = Person::new;
LocalDate birthday = LocalDate.of(2000, 10, 12);
Person person = f.apply(birthday);</code></pre><ol start="2"><li>Example 2</li></ol><p>Lambda Expression</p><pre><code class="language-java">Supplier&lt;Person&gt; s = () -&gt; new Person();
Person person = s.get();</code></pre><p>Method Reference</p><pre><code class="language-java">Supplier&lt;Person&gt; s = Person::new;
Person person = s.get();</code></pre><h3>When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions</h3><ul><li>Local class - Use it if you need to create more than one instance of a class, access its constructor, or introduce a new, named type (because, for example, you need to invoke additional methods later).</li><li>Anonymous class - Use it if you need to declare fields or additional methods.</li><li>Lambda expression or Method reference<ul><li>Use it if you are encapsulating a single unit of behavior that you want to pass to other code. For example, you would use a lambda expression if you want a certain action performed on each element of a collection, when a process is completed, or when a process encounters an error.</li><li>Use it if you need a simple instance of a functional interface and none of the preceding criteria apply (for example, you do not need a constructor, a named type, fields, or additional methods).</li></ul></li><li><p>Nested class</p><ul><li>Use it if your requirements are similar to those of a local class, you want to make the type more widely available, and you don&#x27;t require access to local variables or method parameters.</li><li>Use a non-static nested class (or inner class) if you require access to an enclosing instance&#x27;s non-public fields and methods. Use a static nested class if you don&#x27;t require this access.</li></ul></li></ul><h3>Optional</h3><ul><li><code>null</code> reference is the source of many problems because it is often used to denote the absence of a value</li><li>Java SE 8 introduces a new class called <code>java.util.Optional</code> that can alleviate some of these problems.</li><li>Thus, <code>Optional</code> object is a container object which may or may not contain a non-null value.</li><li>If a value is present, <code>isPresent()</code> will return true and <code>get()</code> will return the value.</li></ul><h4>How to create Optional objects?</h4><ul><li><p>Empty Optional</p><pre><code class="language-java">Optional&lt;String&gt; msgOptional = Optional.empty();</code></pre></li><li><p>Optional with non-null value</p><pre><code class="language-java">String message = “Welcome to Java 8!”;
Optional&lt;String&gt; msgOptional = Optional.of(message);</code></pre><p>If <code>message</code> were <code>null</code>, a <code>NullPointerException</code> would immediately be thrown, rather than getting a latent error once you try to access properties of the <code>message</code> String object.</p></li><li><p>Optional object that may hold a null value</p><pre><code class="language-java">String message = null;
Optional&lt;String&gt; msgOptional = Optional.ofNullable(message);</code></pre></li></ul><p>If <code>message</code> were <code>null</code>, the resulting <code>Optional</code> object would be empty (<code>Optional.empty()</code>) and would not throw <code>NullPointerException</code>.</p><h4>Check Value Presence and Do Action</h4><ul><li><p><code>isPresent()</code></p><ul><li><p>Returns <code>true</code> if the wrapped value is not <code>null</code></p><pre><code class="language-java">Optional&lt;String&gt; msgOptional = …;
if (msgOptional.isPresent()) {
  System.out.println(msgOptional.get());
}</code></pre><p>Before <code>Optional</code>, we would do:</p><pre><code class="language-java">String message = …;
if (message != null) {
  System.out.println(message);
}</code></pre></li></ul></li><li><p><code>ifPresent()</code></p><ul><li><p>Allows to run some codes if it returns <code>true</code>; takes a <code>Consumer</code> function which takes the object being checked as an argument.</p><pre><code class="language-java">Optional&lt;String&gt; msgOptional = …;
msgOptional.ifPresent(m -&gt; System.out.println(m));</code></pre><p>Or</p><pre><code class="language-java">msgOptional.ifPresent(System.out::println);</code></pre></li></ul></li><li><p><code>orElse()</code></p><ul><li><p>Retrieves value wrapped inside an <code>Optional</code> object if it is present and its argument otherwise.</p><pre><code class="language-java">Optional&lt;String&gt; msgOptional = …;
String message = msgOptional.orElse(“Welcome!”);</code></pre><p>Before <code>Optional</code>, we would do:</p><pre><code class="language-java">String message = …;
String msg = message != null ? Message : “Welcome!”;</code></pre></li></ul></li><li><p><code>orElseGet()</code></p><ul><li><p>Similar to <code>orElse()</code>, it retrieves value wrapped inside an <code>Optional</code> object if it is present and its argument otherwise, however, it takes its default value from a <code>Supplier</code> which is invoked and returns the value of invocation.</p><pre><code class="language-java">Optional&lt;String&gt; msgOptional = …;
String message = msgOptional.orElseGet(() -&gt; “Welcome!”);</code></pre></li></ul></li><li><p><code>orElseThrow()</code></p><ul><li><p>Similar to <code>orElse()</code> and <code>orElseGet()</code>, it retrieves value wrapped inside an <code>Optional</code> object if it is present and its argument otherwise. Instead of returning a default value when wrapped value is not present, it throws an exception.</p><pre><code class="language-java">Optional&lt;String&gt; messageOptional = …;
String message = messageOptional.orElseThrow(() -&gt; new IllegalArgumentException());</code></pre><p>Or</p><pre><code class="language-java">Optional&lt;String&gt; messageOptional = …;
String message = messageOptional.orElseThrow(IllegalArgumentException::new);</code></pre></li></ul></li><li><p><code>get()</code></p><ul><li><p>Can only return value if it is present, otherwise, it returns <code>NoSuchElementException</code>.</p><pre><code class="language-java">Optional&lt;String&gt; messageOptional = …;
String message = messageOptional.get();</code></pre><p>Make sure to be defensive against possible <code>NoSuchElementException</code> when using this method:</p><pre><code class="language-java">String message = messageOptional.isPresent() ? messageOptional.get() : “Welcome!”;</code></pre></li></ul></li><li><p><code>filter()</code></p><ul><li><p>If a value is present, and the value matches the given predicate, return an <code>Optional</code> describing the value, otherwise return an empty <code>Optional</code>.</p><p>Example</p><pre><code class="language-java">Optional&lt;String&gt; answerOptional = Optional.of(“YES”)
    .filter(b -&gt; b.equalsIgnorecase(“yes”));</code></pre></li><li><p>If a value is present, and the value matches the given predicate, return an <code>Optional</code> describing the value, otherwise return an empty <code>Optional</code>.</p><p>Example</p><pre><code class="language-java">LocalDate birthday = LocalDate.of(2000, 7, 23);
Optional&lt;LocalDate&gt; legalAgeOptional1 = Optional.of(birthday)
    .filter(this::isLegalAge);</code></pre><pre><code class="language-java">public boolean isLegalAge(LocalDate birthday) {
  LocalDate currentDate = LocalDate.now(); // 2019-5-24
  Period interval = Period.between(birthday, currentDate);

  return interval.getYears() &gt; 17;
}</code></pre><p>Above code will return <code>Optional</code> with a LocalDate value since filter meets the predicate.</p></li></ul></li><li><p><code>map()</code></p><ul><li><p>Transforms value - if a value is present, apply the provided mapping function to it, and if the result is non-null, return an <code>Optional</code> describing the result. Otherwise return an empty <code>Optional</code>.</p><p>Example 1</p><pre><code class="language-java">List&lt;String&gt; frameworks = Arrays.asList(&quot;Spring&quot;, “Spring Fu”, &quot;Quarkus&quot;, &quot;Micronaut&quot;, &quot;Play&quot;, &quot;Struts&quot;, &quot;Spark&quot;, &quot;Summer Fun&quot;);
Optional&lt;List&lt;String&gt;&gt; listOptional = Optional.of(frameworks);
int size = listOptional
    .map(List::size) // Lambda expression .map(list -&gt; list.size())
    .orElse(0);</code></pre><p>Above code will return an integer value since mapping function is to get the size of <code>List</code>.</p><p>Example 2</p><pre><code class="language-java">class Person {
  public Optional&lt;String&gt; getName() {
    return Optional.of(&quot;Digong&quot;);
  }
}</code></pre><pre><code class="language-java">Person person = new Person();
Optional&lt;Person&gt; personOptional = Optional.of(person);
Optional&lt;Optional&lt;String&gt;&gt; nameOptionalWrapper = personOptional.map(Person::getName);
Optional&lt;String&gt; nameOptional = nameOptionalWrapper.orElse(Optional.empty());
String name = nameOptional.orElse(&quot;&quot;);</code></pre><p>With <code>.map()</code>, we still need to get <code>Optional</code> that wraps another <code>Optional</code> (line 3). Then, <code>.orElse()</code>, line 4, gets the <code>Optional</code> wrapped in <code>Optional</code>. Finally, the last <code>.orElse()</code> extracts the name value.</p></li></ul></li><li><p><code>flatMap()</code></p><ul><li><p>If a value is present, apply the provided <code>Optional</code>-bearing mapping function to it, return that result, otherwise return an empty <code>Optional</code>. This method is similar to <code>map()</code>, but the provided mapper is one whose result is already an <code>Optional</code>, and if invoked, <code>flatMap()</code> does not wrap it with an additional <code>Optional</code>.</p><pre><code class="language-java">Person person = new Person();
Optional&lt;Person&gt; personOptional = Optional.of(person);
Optional&lt;String&gt; nameOptional = personOptional.flatMap(Person::getName);
// Lambda expression: personOptional.flatMap(p -&gt; p.getName());
String name = nameOptional.orElse(&quot;&quot;);</code></pre><p><code>.flatMap()</code> already returns the <code>Optional</code> wrapped in another <code>Optional</code>. We have saved a single line.</p></li></ul></li></ul><h3>Stream API</h3><ul><li>A sequence of elements supporting sequential and parallel aggregate operations.</li><li>Collections in Java 8 are extended so you can simply create streams either by calling <code>Collection.stream()</code> or <code>Collection.parallelStream()</code></li><li><code>Stream</code> operations are either <strong>intermediate</strong> or <strong>terminal</strong><ul><li><strong>Intermediate operations</strong> return the <code>Stream</code> itself so you can chain multiple method calls in a row<ul><li><code>filter</code></li><li><code>sorted</code></li><li><code>map</code></li></ul></li><li><strong>Terminal operations</strong> return a result of a certain type<ul><li><code>forEach</code></li><li><code>allMatch</code></li><li><code>findFirst</code></li><li><code>count</code></li><li><code>reduce</code></li><li><code>collect</code></li></ul></li></ul></li></ul><h4>Stream - filter()</h4><p>Returns a stream consisting of the elements of this stream that match the given predicate.</p><p>Example:</p><pre><code class="language-java">List&lt;String&gt; frameworks = new ArrayList&lt;&gt;();
frameworks.add(&quot;Spring&quot;);
frameworks.add(&quot;Spring Fu&quot;);
frameworks.add(&quot;Quarkus&quot;);
frameworks.add(&quot;Micronaut&quot;);
frameworks.add(&quot;Play&quot;);
frameworks.add(&quot;Struts&quot;);
frameworks.add(&quot;Spark&quot;);
frameworks.add(&quot;Summer Fun&quot;);

List&lt;String&gt; frameworks = frameworks();
List&lt;String&gt; frameworksStartWithS = frameworks.stream()
        .filter(framework -&gt; framework.startsWith(&quot;S&quot;))
        .collect(Collectors.toList());</code></pre><h4>Stream - sorted()</h4><p>Returns a stream consisting of the elements of this stream, sorted according to natural order.</p><p>Example</p><pre><code class="language-java">List&lt;String&gt; frameworks = frameworks();
List&lt;String&gt; frameworksSorted = frameworks.stream()
        .sorted()
        .collect(Collectors.toList());

// reversed
List&lt;String&gt; frameworksReversed = frameworks.stream()
        .sorted(Collections.reverseOrder())
        .collect(Collectors.toList());</code></pre><h4>Stream - map()</h4><p>Returns a stream consisting of the results of applying the given function to the elements of this stream.</p><p>Example</p><pre><code class="language-java">List&lt;String&gt; frameworks = frameworks();</code></pre><p>Lambda Expression</p><pre><code class="language-java">List&lt;String&gt; frameworksToUpperCase = frameworks.stream()
        .map(framework -&gt; framework.toUpperCase())
        .collect(Collectors.toList());</code></pre><p>Method Reference</p><pre><code class="language-java">List&lt;String&gt; frameworksToUpperCase = frameworks.stream()
        .map(String::toUpperCase)
        .collect(Collectors.toList());</code></pre><h4>Stream - forEach()</h4><p>Returns an iterator over elements.</p><p>Example</p><pre><code class="language-java">List&lt;String&gt; frameworks = frameworks();</code></pre><p>Lambda Expression</p><pre><code class="language-java">frameworks.forEach(framework -&gt; System.out.println(framework));</code></pre><p>Method Reference</p><pre><code class="language-java">frameworks.forEach(System.out::println);</code></pre><h4>Stream - allMatch()</h4><p>Returns whether all elements of this stream match the provided predicate.</p><p>Example</p><pre><code class="language-java">List&lt;String&gt; frameworks = frameworks();
boolean allMatched = frameworks.stream()
        .allMatch(framework -&gt; framework.split(&quot; &quot;).length &gt; 1);</code></pre><h4>Stream - findFirst()</h4><p>Returns whether all elements of this stream match the provided predicate.</p><p>Example</p><pre><code class="language-java">List&lt;String&gt; frameworks = frameworks();
Optional&lt;String&gt; frameworkOptional = frameworks.stream()
        .filter(framework -&gt; framework.contains(&quot;Fund&quot;))
        .findFirst();</code></pre><h4>Stream - count()</h4><p>Returns the count of elements in this stream.</p><p>Example</p><pre><code class="language-java">List&lt;String&gt; frameworks = frameworks();
long countAll = frameworks.stream()
        .count();
long countStartsWithS = frameworks.stream()
        .filter(framework -&gt; framework.startsWith(&quot;S&quot;))
        .count();</code></pre><h4>Stream - reduce()</h4><p>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.</p><p>Example</p><pre><code class="language-java">Integer[] grades = {90, 85, 92, 98, 88, 93};
Optional&lt;Integer&gt; totalOptional = Stream.of(grades)
        .reduce((g1, g2) -&gt; g1 + g2);
totalOptional.ifPresent(System.out::println);</code></pre><h4>Stream - collect()</h4><p>Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.</p><p>Example 1</p><pre><code class="language-java">Integer[] grades = {90, 85, 92, 98, 88, 93};
List&lt;Integer&gt; gradeList = Stream.of(grades)
        .filter(grade -&gt; grade &gt; 89)
        .collect(Collectors.toList());</code></pre><p>Example 2</p><pre><code class="language-java">List&lt;User&gt; users = Arrays.asList(
new User(&quot;John&quot;, &quot;ADMIN&quot;),
new User(&quot;Luke&quot;, &quot;USER&quot;),
new User(&quot;Matthew&quot;, &quot;USER&quot;),
new User(&quot;Mark&quot;, &quot;USER&quot;),
new User(&quot;Paul&quot;, &quot;ADMIN&quot;));

Map&lt;String, User&gt; userMap = users.stream()
        .collect(Collectors.toMap(User::getRole, user -&gt; user));</code></pre><h3>New Date and Time API</h3><ul><li>The Date-Time APIs, introduced in JDK 8, are a set of packages that model the most important aspects of date and time</li><li>The core classes in the java.time package use the calendar system defined in <strong>ISO-8601</strong> (based on the Gregorian calendar system) as the default calendar.<ul><li><code>java.time</code> - Classes for date, time, date and time combined, time zones, instants, duration, and clocks.</li><li><code>java.time.chrono</code> - API for representing calendar systems other than ISO-8601. Several predefined chronologies are provided and you can also define your own chronology.</li><li><code>java.time.format</code> - Classes for formatting and parsing dates and time.</li><li><code>java.time.temporal</code> - Extended API, primarily for framework and library writers, allowing interoperations between the date and time classes, querying, and adjustment. Fields and units are defined in this package.</li><li><code>java.time.zone</code> - Classes that support time zones, offsets from time zones, and time zone rules. on the Gregorian calendar system) as the default calendar.</li></ul></li><li>Old Date API<ul><li>Existing classes aren’t thread-safe, leading to potential concurrency issues for users—not something the average developer would expect to deal with when writing date-handling code.</li><li>Some of the date and time classes also exhibit quite poor API design. For example, years in <code>java.util.Date</code> start at 1900, months start at 1, and days start at 0—not very intuitive.</li><li>These issues, and several others, have led to the popularity of third-party date and time libraries, such as Joda-Time.</li></ul></li></ul><p>The project, <strong>Date and Time API</strong>, has been led jointly by the author of <strong>Joda-Time</strong> (<strong>Stephen Colebourne</strong>) and Oracle, under <strong>JSR 310</strong>, and appears in the new Java SE 8 package <code>java.time</code>.</p><h4>New Date and Time API - Clock</h4><p><strong>Clock</strong></p><ul><li>A clock providing access to the current instant, date and time using a time-zone.</li></ul><p>Example</p><pre><code class="language-java">Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();

Instant instant = clock.instant();
Date legacyDate = Date.from(instant);</code></pre><h4>New Date and Time API - Timezone</h4><p><strong>ZoneId</strong></p><ul><li>A time-zone ID, such as <code>Asia/Manila</code>. A <code>ZoneId</code> is used to identify the rules used to convert between, an <code>Instant</code> and a <code>LocalDateTime</code>.</li></ul><p>Example</p><pre><code class="language-java">Set&lt;ZoneId&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</code></pre><pre><code class="language-java">ZoneId zone1 = ZoneId.of(&quot;Asia/Manila&quot;);
ZoneId zone2 = ZoneId.of(&quot;Europe/Paris&quot;);
System.out.println(zone1.getRules());   // ZoneRules[currentStandardOffset=+08:00]
System.out.println(zone2.getRules());   // ZoneRules[currentStandardOffset=+01:00]</code></pre><h4>New Date and Time API - LocalTime</h4><p><strong>LocalTime</strong></p><ul><li>A time without a time-zone in the ISO-8601 calendar system, such as <code>08:24:15</code>.</li></ul><p>Example</p><pre><code class="language-java">ZoneId zone1 = ZoneId.of(&quot;Asia/Manila&quot;);
ZoneId zone2 = ZoneId.of(&quot;Europe/Paris&quot;);
LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2);

System.out.println(now1.isBefore(now2));  // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween);       // -6
System.out.println(minutesBetween);     // -360</code></pre><h4>New Date and Time API - LocalDate</h4><p><strong>LocalDate</strong></p><ul><li>A date without a time-zone in the ISO-8601 calendar system, such as <code>2019-05-24</code>.</li></ul><p>Example</p><pre><code class="language-java">LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
LocalDate yesterday = tomorrow.minusDays(2);

LocalDate independenceDay = LocalDate.of(2019, Month.MAY, 24);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
System.out.println(dayOfWeek);    // FRIDAY</code></pre><h4>New Date and Time API - LocalDateTime</h4><p><strong>LocalDateTime</strong></p><ul><li>A date-time without a time-zone in the ISO-8601 calendar system, such as <code>2019-05-24T08:24:15</code>.</li></ul><p>Example</p><pre><code class="language-java">LocalDateTime ldt = LocalDateTime.of(2019, Month.MAY, 24, 14, 55, 59);

DayOfWeek dayOfWeek = ldt.getDayOfWeek();
System.out.println(dayOfWeek);      // FRIDAY

Month month = ldt.getMonth();
System.out.println(month);          // MAY

long minuteOfDay = ldt.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);    // 895</code></pre><hr/><h1>References</h1><ol><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8">https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8</a></li><li><a href="https://www.tutorialspoint.com/java8/index.htm">https://www.tutorialspoint.com/java8/index.htm</a></li><li><a href="https://winterbe.com/posts/2014/03/16/java-8-tutorial/">https://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></li><li><a href="https://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html">https://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html</a></li><li><a href="https://www.baeldung.com/java-optional">https://www.baeldung.com/java-optional</a></li><li><a href="https://www.baeldung.com/java-8-streams">https://www.baeldung.com/java-8-streams</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html">https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html</a></li></ol></div></div><div class="row"><div class="col"><hr/></div></div><div class="row justify-content-center"><div class="col"><div id="disqus_thread" style="padding-top:4rem"></div><script src="/assets/js/disqus.js"></script><noscript>Please enable JavaScript to view the<!-- --> <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></div></div></section></main><footer class="text-white bg-deep-orange" style="padding:6rem 0"><div class="container"><div class="row mb-4 justify-content-center"><div class="col-auto"><a href="index.html"><img src="/assets/images/logo.png" alt="Julian Jupiter&#x27;s logo" class="icon icon-lg" style="height:100px;border:10px solid #fff;border-radius:50%"/></a></div></div><div class="row justify-content-center mb-2"><div class="col-auto"><ul class="nav"><li class="nav-item"><a class="nav-link text-white font-weight-bold" target="_blank" href="https://julianjupiter.com/">Home</a></li><li class="nav-item"><a class="nav-link text-white font-weight-bold" target="_blank" href="https://julianjupiter.com/priofile">Profile</a></li><li class="nav-item"><a class="nav-link text-white font-weight-bold" target="_blank" href="https://julianjupiter.com/blog">Blog</a></li><li class="nav-item"><a class="nav-link text-white font-weight-bold" target="_blank" href="https://julianjupiter.com/projects">Projects</a></li></ul></div></div><div class="row justify-content-center mb-2"><div class="col-auto"><ul class="nav"><li class="nav-item"><a class="nav-link" target="_blank" href="https://github.com/julianjupiter"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github-square" class="svg-inline--fa fa-github-square fa-w-14 text-white" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" style="flex-shrink:0;width:auto;height:4rem"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg></a></li><li class="nav-item"><a class="nav-link" target="_blank" href="https://gitlab.com/julianjupiter"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="gitlab" class="svg-inline--fa fa-gitlab fa-w-16 text-white" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="flex-shrink:0;width:auto;height:4rem"><path fill="currentColor" d="M105.2 24.9c-3.1-8.9-15.7-8.9-18.9 0L29.8 199.7h132c-.1 0-56.6-174.8-56.6-174.8zM.9 287.7c-2.6 8 .3 16.9 7.1 22l247.9 184-226.2-294zm160.8-88l94.3 294 94.3-294zm349.4 88l-28.8-88-226.3 294 247.9-184c6.9-5.1 9.7-14 7.2-22zM425.7 24.9c-3.1-8.9-15.7-8.9-18.9 0l-56.6 174.8h132z"></path></svg></a></li><li class="nav-item"><a class="nav-link" target="_blank" href="https://www.fcaebook.com/julianjupiter"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="facebook-square" class="svg-inline--fa fa-facebook-square fa-w-14 text-white" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" style="flex-shrink:0;width:auto;height:4rem"><path fill="currentColor" d="M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h137.25V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.27c-30.81 0-40.42 19.12-40.42 38.73V256h68.78l-11 71.69h-57.78V480H400a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48z"></path></svg></a></li><li class="nav-item"><a class="nav-link" target="_blank" href="https://twitter.com/julianvjupiter"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter-square" class="svg-inline--fa fa-twitter-square fa-w-14 text-white" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" style="flex-shrink:0;width:auto;height:4rem"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li></ul></div></div><div class="row justify-content-center"><div class="col col-md-auto text-center"><small class="text-white">Copyright ©<!-- --> <span id="currentYear">2020</span> <a class="text-white" href="https://julianjupiter.com/">Julian Jupiter</a><p>All Rights Reserved</p></small></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Java 8 New Language Features","excerpt":"This post discusses the new features introduced to Java 8 language.","date":"2019-07-06","image":{"cover":"","og":""},"slug":"java-8-new-language-features","content":"\r\n### Overview\r\n\r\nThis post discusses the new language features of **Java 8**. Java 8's release is the most awaited and is a major feature release of Java programming language.\r\n\r\nThese new features include **functional interfaces**, **interface default method**, **lambda expressions**, **method references**, **Optional**, and **Stream API**. We will also talk about some of **built-in functions** that implement Function Interface and the **New Date and Time API**.\r\n\r\n### Functional Interface\r\n\r\nFunctional Interface is an interface with **single abstract method (SAM)**. Static or the new default method is not counted. To indicate that an interface is a **Functional Interface**, annotation `@FunctionalInterface` on class level is needed. While an interface with SAM could still function as **Functional Interface** (qualified as lambda expression) even if it does not have such annotation (example is AWT's `ActionListener`), it is recommended that it be annotated.\r\n\r\nSome old built-in interfaces with SAM, such as `Comparator` and `Runnable`, have been annotated with `@FunctionalInterface` and can be used as lambda expressions.\r\n\r\n#### Example\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Calculator {\r\n  long calculate(long x, long y);\r\n}\r\n```\r\n\r\nWe can implement above interface in two ways prior to Java 8.\r\n\r\n- Anonymous class\r\n\r\n  ```java\r\n  Calculator division = new Calculator() {\r\n    @Override\r\n    public long calculate(long x, long y) {\r\n      return x / y;\r\n    }\r\n  };\r\n\r\n  long quotient = division.calculate(10, 2);\r\n  ```\r\n\r\n- Concrete class\r\n\r\n  ```java\r\n  class Division implements Calculator {\r\n    @Override\r\n      public long calculate(long x, long y) {\r\n      return x / y;\r\n    }\r\n  }\r\n  ```\r\n\r\n  ```java\r\n  Calculator division = new Division() ;\r\n  long quotient = division.calculate(10, 2);\r\n  ```\r\n\r\nWith Java 8, there is a third way to to implement an interface and that is by using **Lambda Expressions**.\r\n\r\n### Lambda Expressions\r\n\r\nLambda expressions encapsulate a single unit of behavior and pass it to other code. To be able to create lambda expression, you need first a Funtional Interface. This is the reason why a Functional Interface has a single abstract method. Instead of an anonymous class, you can use lambda expression which is a concise alternative and shorthand replacement for it.\r\n\r\n#### Syntax\r\n\r\n```java\r\nparameter -\u003e expression or statement body\r\n```\r\n\r\n#### Example\r\n\r\n```java\r\n(Integer x) -\u003e { return x; };\r\n```\r\n\r\n#### Characteristics of Lambda Expression\r\n\r\n1. Optional type declaration\r\n\r\n```java\r\n(x) -\u003e { return x; };\r\n```\r\n\r\n2. Optional parentheses\u003cbr\u003e\r\n\r\n```java\r\nx -\u003e { return x; };\r\n```\r\n\r\nParentheses are required if there are multiple parameters. Parameters are separated by comma (`,`).\r\n\r\n```java\r\n(x, y) -\u003e { return x + y; };\r\n```\r\n\r\n3. Optional curly braces (`{}`) and optional `return` keyword\r\n\r\n```java\r\nx -\u003e x;\r\n```\r\n\r\nCurly braces are required if body has multiple statements. `return` keyword is required for a function with return value if body has multiple statements. No `return` keyword is required if function does not return a value as in regular method.\r\n\r\n```java\r\nx -\u003e {\r\n  System.out.println(\"Hello world!\");\r\n  return x;\r\n};\r\n```\r\n\r\n```java\r\nx -\u003e {\r\n  System.out.println(\"Hello world!\");\r\n  System.out.println(\"Welcome to Java 8 Programming!\");\r\n};\r\n```\r\n\r\nRemember our `Calculator` interface? Here is how to implement it using lambda expression:\r\n\r\n```java\r\nCalculator multiplication = (a, b) -\u003e a * b;    // or (a, b) -\u003e Math.multiplyExact(a, b);\r\nCalculator division = (a, b) -\u003e a / b;\r\nCalculator addition = (a, b) -\u003e a + b;          // or (a, b) -\u003e Math.addExact(a, b);\r\nCalculator subtraction = (a, b) -\u003e a - b;       // or (a, b) -\u003e Math.subtractExact(a, b);\r\n\r\nlong product = multiplication.calculate(5, 5);\r\nlong quotient = division.calculate(10, 2);\r\nlong sum = addition.calculate(5, 5);\r\nlong difference = subtraction.calculate(10, 4);\r\n```\r\n\r\n### Built-in Functions\r\n\r\nJava 8 ships 43 built-in functions under `java.util.function` package. **Thirty eight** (**38**) of them are specialization for primitive and other functions.\r\n\r\nThe following are the basic functions:\r\n\r\n1. `Function`\r\n2. `Consumer`\r\n3. `Supplier`\r\n4. `Predicate`\r\n\r\n#### Function\r\n\r\nFunction represents a function that accepts one argument and produces a result. The type parameter `T` represents the type of the input to the function while the second one R represents the type of result. The functonal method of this functional interface is `apply(Object)`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Function\u003cT,R\u003e\r\n```\r\n\r\n##### Examples\r\n\r\nBelow is an example of Function that accepts a String argument and returns a String.\r\n\r\n```java\r\nFunction\u003cString, String\u003e f1 = a -\u003e a;\r\nString message = f1.apply(\"Welcome to Java 8!\");\r\n```\r\n\r\nThis one accepts a String argument and returns an integer.\r\n\r\n```java\r\nFunction\u003cString, Integer\u003e f2 = a -\u003e a.length();\r\nint textLength = f2.apply(\"Welcome to Java 8!\");\r\n```\r\n\r\n#### Consumer\r\n\r\nConsumer represents an operation that accepts a single input argument and returns no result. The type parameter `T` represents the type of the input to the operation. The functonal method of this functional interface is `accept(Object)`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Consumer\u003cT\u003e\r\n```\r\n\r\n##### Examples\r\n\r\nBoth accept String input argument and returns no value.\r\n\r\n```java\r\nConsumer\u003cString\u003e c1 = a -\u003e System.out.println(a);\r\nc1.accept(\"Welcome to Java 8!\");\r\n\r\nConsumer\u003cString\u003e c2 = a -\u003e {\r\n  String message = \"Welcome to \" + a + \"!\";\r\n  System.out.println(message);\r\n};\r\nc2.accept(\"Java 8\");\r\n```\r\n\r\n#### Supplier\r\n\r\nSupplier Represents a supplier of results. The type parameter `T` represents the type of results supplied by the supplier. This is a functional interface whose functional method is `get()`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Supplier\u003cT\u003e\r\n```\r\n\r\n##### Examples\r\n\r\nThis example returns a value of String type.\r\n\r\n```java\r\nSupplier\u003cString\u003e stringSupplier = () -\u003e \"Welcome to Java 8!\";\r\nString message = stringSupplier.get();\r\n```\r\n\r\nAnd this one returns a value of User type.\r\n\r\n```java\r\nSupplier\u003cUser\u003e userSupplier = () -\u003e new User();\r\nUser user = userSupplier.get();\r\n```\r\n\r\n#### Predicate\r\n\r\nPredicate represents a predicate (boolean-valued function) of one argument. The type parameter `T` represents the type of the input to the predicate. This is a functional interface whose functional method is `test(Object)`.\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Predicate\u003cT\u003e\r\n```\r\n\r\n##### Examples\r\n\r\nTo check if argument is equal to \"YES\" regardless of case:\r\n\r\n```java\r\nPredicate\u003cString\u003e answerPredicate = a -\u003e \"YES\".equalsIgnoreCase(a);\r\nboolean isYes = answerPredicate.test(\"Yes\");\r\n```\r\n\r\nTo check if person is of legal age (18 and above):\r\n\r\n```java\r\npublic static Predicate\u003cInteger\u003e isLegalAge() {\r\n  return age -\u003e age \u003e= 18;\r\n}\r\n```\r\n\r\n```java\r\nboolean legalAge = isLegalAge().test(18);\r\n```\r\n\r\n#### Built-in Functions - Specialization\r\n\r\nOther built-in functions are specializations for primitive types and for basic or another specialization functions.\r\n\r\nTo check all other built-in functions, please visit this \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html\" target=\"blank\"\u003eJavadoc\u003c/a\u003e.\r\n\r\n#### Existing Interface - Comparator\r\n\r\n`Comparator` is an existing interface in Java since version 1.2. This interface has a single abstract method, `compare(T o1, T o2)`, and, therefore, can be used as lambda expression similar to functions added to Java 8.\r\n\r\nPrior to Java 8, we would use \u003cspan class=\"inline-code\"\u003eComparator\u003c/span\u003e in sorting a collection the following way:\r\n\r\n```java\r\nList\u003cString\u003e choices = Arrays.asList(\"c\", \"a\", \"d\", \"b\", \"e\");\r\n\r\nCollections.sort(choices, new Comparator\u003cString\u003e() {\r\n  @Override\r\n  public int compare(String a, String b) {\r\n    return a.compareTo(b);\r\n  }\r\n});\r\n```\r\n\r\nWith Java 8:\r\n\r\n```java\r\nComparator\u003cString\u003e comparator = (a, b) -\u003e a.compareTo(b);\r\nCollections.sort(choices, comparator);\r\n```\r\n\r\n```java\r\nCollections.sort(choices, (String a, String b) -\u003e {\r\n  return a.compareTo(b);\r\n});\r\n```\r\n\r\n```java\r\nCollections.sort(choices, (String a, String b) -\u003e a.compareTo(b));\r\n```\r\n\r\n```java\r\nCollections.sort(choices, (a, b) -\u003e a.compareTo(b));\r\n```\r\n\r\n### Default Methods\r\n\r\nDefault methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces. They are interface methods that have an implementation, similar to static methods, and the `default` keyword at the beginning of the method signature.\r\n\r\n#### Syntax\u003c/h4\u003e\r\n\r\n```java\r\ndefault type methodName(type parameter) {\r\n  body\r\n}\r\n```\r\n\r\nFor example, default method `forEach()` was added to `Iterable` interface. This method takes a `Consumer` argument and performs action for each element (similar to enhanced `for-each` construct). `List` interface which extends `Iterable` can now be used with `forEach()` method:\r\n\r\n```java\r\nList\u003cString\u003e days = Arrays.asList(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\");\r\ndays.forEach(day -\u003e System.out.println(day));\r\n```\r\n\r\n#### Example\r\n\r\n```java\r\npublic interface Calculator {\r\n  double calculate(double number);\r\n\r\n  default double sqrt(double number) {\r\n    return Math.sqrt(number);\r\n  }\r\n}\r\n```\r\n\r\n```java\r\nCalculator sc = x -\u003e x * x;\r\ndouble square = sc.calculate(10.0); // 100.0\r\ndouble sqrt = sc.sqrt(square);      // 10.0\r\n```\r\n\r\n### Method References\r\n\r\nJava 8 enables you to pass references of methods or constructors via the :: keyword. Method references are compact, easy-to-read lambda expressions for methods that already have a name. They are preferred over lambda expression if the expression does nothing but calls an existing method.\r\n\r\n#### Syntax\r\n\r\n```java\r\nReference::methodName\r\n```\r\n\r\n#### Types of Method References\r\n\r\n\u003ctable class=\"table table-bordered table-striped\"\u003e\r\n    \u003cthead\u003e\r\n        \u003ctr\u003e\r\n            \u003cth scope=\"col\"\u003eType\u003c/th\u003e\r\n            \u003cth scope=\"col\"\u003eExample\u003c/th\u003e\r\n        \u003c/tr\u003e\r\n    \u003c/thead\u003e\r\n    \u003ctbody\u003e\r\n        \u003ctr\u003e\r\n            \u003cth scope=\"row\"\u003eReference to a static method\u003c/th\u003e\r\n            \u003ctd\u003eContainingClass::staticMethodName\u003c/td\u003e\r\n        \u003c/tr\u003e\r\n        \u003ctr\u003e\r\n            \u003cth scope=\"row\"\u003eReference to an instance method of a particular object\u003c/th\u003e\r\n            \u003ctd\u003econtainingObject::instanceMethodName\u003c/td\u003e\r\n        \u003c/tr\u003e\r\n        \u003ctr\u003e\r\n            \u003cth scope=\"row\"\u003eReference to an instance method of an arbitrary object of a particular type\u003c/th\u003e\r\n            \u003ctd\u003eContainingType::methodName\u003c/td\u003e\r\n        \u003c/tr\u003e\r\n        \u003ctr\u003e\r\n            \u003cth scope=\"row\"\u003eReference to a constructor\u003c/th\u003e\r\n            \u003ctd\u003eClassName::new\u003c/td\u003e\r\n        \u003c/tr\u003e\r\n    \u003c/tbody\u003e\r\n\u003c/table\u003e\r\n\r\n#### Example\r\n\r\n##### Reference to a static method\r\n\r\n1. Example 1\r\n\r\n```java\r\nclass Person {\r\n  private LocalDate birthday;\r\n\r\n  public Person() {}\r\n\r\n  public Person(LocalDate birthday) {\r\n    this.birthday = birthday;\r\n  }\r\n\r\n  // setters, getters\r\n\r\n  public static int compareByAge(Person a, Person b) {\r\n    return a.birthday.compareTo(b.birthday);\r\n  }\r\n}\r\n```\r\n\r\n```java\r\nPerson p1 = new Person(LocalDate.of(2000, 6, 21));\r\nPerson p2 = new Person(LocalDate.of(2000, 6, 15));\r\nPerson p3 = new Person(LocalDate.of(1998, 3, 28));\r\nPerson[] persons = {p1, p2, p3};\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nArrays.sort(persons, (p1, p2) -\u003e Person.compareByAge(p1, p2));\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nArrays.sort(persons, Person::compareByAge);\r\n```\r\n\r\n1. Example 2\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface StringToIntConverter {\r\n  int convert(String string);\r\n}\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nStringToIntConverter converter = s -\u003e Integer.valueOf(s);\r\nint i = converter.convert(\"10\");\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nStringToIntConverter converter = Integer::valueOf;\r\nint i = converter.convert(\"10\");\r\n```\r\n\r\n##### Reference to an instance method of a particular object\r\n\r\n1. Example 1\r\n\r\n```java\r\npublic class Something {\r\n  public int getYear(LocalDate localDate) {\r\n    return localDate.getYear();\r\n  }\r\n}\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nSomething something = new Something();\r\nFunction\u003cLocalDate, Integer\u003e f = d -\u003e something.getYear(d);\r\nint year = f.apply(p1.getBirthday());\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nSomething something = new Something();\r\nFunction\u003cLocalDate, Integer\u003e f = something::getYear;\r\nint year = f.apply(p1.getBirthday());\r\n```\r\n\r\n2. Example 2\r\n\r\n```java\r\npublic interface PersonDao {\r\n  Person findById(int id);\r\n}\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nPersonDao personDao = new PersonDaoImpl();\r\nFunction\u003cInteger, Person\u003e f = id -\u003e personDao.findById(id);\r\nPerson person = f.apply(1);\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nPersonDao personDao = new PersonDaoImpl();\r\nFunction\u003cInteger, Person \u003e f = personDao::findById;\r\nPerson person = f.apply(1);\r\n```\r\n\r\n##### Reference to an instance method of an arbitrary object of a particular type\r\n\r\n1. Example 1\r\n\r\nLambda Expression\r\n\r\n```java\r\nFunction\u003cString, String\u003e f = s -\u003e s.toUpperCase();\r\nString httpGet = f.apply(\"get\");\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nFunction\u003cString, String\u003e f = String::toUpperCase;\r\nString httpGet = f.apply(\"get\");\r\n```\r\n\r\n2. Example 2\r\n\r\nLambda Expression\r\n\r\n```java\r\nPerson person = ...\r\nFunction\u003cPerson, LocalDate\u003e f = p -\u003e p.getBirthday();\r\nLocalDate birthday = f.apply(person);\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nPerson person = ...\r\nFunction\u003cPerson, LocalDate\u003e f = Person::getBirthday;\r\nLocalDate birthday = f.apply(person);\r\n```\r\n\r\n##### Reference to a constructor\u003c/h5\u003e\r\n\r\n1. Example 1\r\n\r\nLambda Expression\r\n\r\n```java\r\nFunction\u003cLocalDate, Person\u003e f = d -\u003e new Person(d);\r\nLocalDate birthday = LocalDate.of(2000, 10, 12);\r\nPerson person = f.apply(birthday);\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nFunction\u003cLocalDate, Person\u003e f = Person::new;\r\nLocalDate birthday = LocalDate.of(2000, 10, 12);\r\nPerson person = f.apply(birthday);\r\n```\r\n\r\n2. Example 2\r\n\r\nLambda Expression\r\n\r\n```java\r\nSupplier\u003cPerson\u003e s = () -\u003e new Person();\r\nPerson person = s.get();\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nSupplier\u003cPerson\u003e s = Person::new;\r\nPerson person = s.get();\r\n```\r\n\r\n### When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions\r\n\r\n- Local class - Use it if you need to create more than one instance of a class, access its constructor, or introduce a new, named type (because, for example, you need to invoke additional methods later).\r\n- Anonymous class - Use it if you need to declare fields or additional methods.\r\n- Lambda expression or Method reference\r\n  - Use it if you are encapsulating a single unit of behavior that you want to pass to other code. For example, you would use a lambda expression if you want a certain action performed on each element of a collection, when a process is completed, or when a process encounters an error.\r\n  - Use it if you need a simple instance of a functional interface and none of the preceding criteria apply (for example, you do not need a constructor, a named type, fields, or additional methods).\r\n- Nested class\r\n\r\n  - Use it if your requirements are similar to those of a local class, you want to make the type more widely available, and you don't require access to local variables or method parameters.\r\n  - Use a non-static nested class (or inner class) if you require access to an enclosing instance's non-public fields and methods. Use a static nested class if you don't require this access.\r\n\r\n### Optional\r\n\r\n- `null` reference is the source of many problems because it is often used to denote the absence of a value\r\n- Java SE 8 introduces a new class called `java.util.Optional` that can alleviate some of these problems.\r\n- Thus, `Optional` object is a container object which may or may not contain a non-null value.\r\n- If a value is present, `isPresent()` will return true and `get()` will return the value.\r\n\r\n#### How to create Optional objects?\r\n\r\n- Empty Optional\r\n\r\n  ```java\r\n  Optional\u003cString\u003e msgOptional = Optional.empty();\r\n  ```\r\n\r\n- Optional with non-null value\r\n\r\n  ```java\r\n  String message = “Welcome to Java 8!”;\r\n  Optional\u003cString\u003e msgOptional = Optional.of(message);\r\n  ```\r\n\r\n  If `message` were `null`, a `NullPointerException` would immediately be thrown, rather than getting a latent error once you try to access properties of the `message` String object.\r\n\r\n- Optional object that may hold a null value\r\n\r\n  ```java\r\n  String message = null;\r\n  Optional\u003cString\u003e msgOptional = Optional.ofNullable(message);\r\n  ```\r\n\r\nIf `message` were `null`, the resulting `Optional` object would be empty (`Optional.empty()`) and would not throw `NullPointerException`.\r\n\r\n#### Check Value Presence and Do Action\r\n\r\n- `isPresent()`\r\n\r\n  - Returns `true` if the wrapped value is not `null`\r\n\r\n    ```java\r\n    Optional\u003cString\u003e msgOptional = …;\r\n    if (msgOptional.isPresent()) {\r\n      System.out.println(msgOptional.get());\r\n    }\r\n    ```\r\n\r\n    Before `Optional`, we would do:\r\n\r\n    ```java\r\n    String message = …;\r\n    if (message != null) {\r\n      System.out.println(message);\r\n    }\r\n    ```\r\n\r\n- `ifPresent()`\r\n\r\n  - Allows to run some codes if it returns `true`; takes a `Consumer` function which takes the object being checked as an argument.\r\n\r\n    ```java\r\n    Optional\u003cString\u003e msgOptional = …;\r\n    msgOptional.ifPresent(m -\u003e System.out.println(m));\r\n    ```\r\n\r\n    Or\r\n\r\n    ```java\r\n    msgOptional.ifPresent(System.out::println);\r\n    ```\r\n\r\n- `orElse()`\r\n\r\n  - Retrieves value wrapped inside an `Optional` object if it is present and its argument otherwise.\r\n\r\n    ```java\r\n    Optional\u003cString\u003e msgOptional = …;\r\n    String message = msgOptional.orElse(“Welcome!”);\r\n    ```\r\n\r\n    Before `Optional`, we would do:\r\n\r\n    ```java\r\n    String message = …;\r\n    String msg = message != null ? Message : “Welcome!”;\r\n    ```\r\n\r\n- `orElseGet()`\r\n\r\n  - Similar to `orElse()`, it retrieves value wrapped inside an `Optional` object if it is present and its argument otherwise, however, it takes its default value from a `Supplier` which is invoked and returns the value of invocation.\r\n\r\n    ```java\r\n    Optional\u003cString\u003e msgOptional = …;\r\n    String message = msgOptional.orElseGet(() -\u003e “Welcome!”);\r\n    ```\r\n\r\n- `orElseThrow()`\r\n\r\n  - Similar to `orElse()` and `orElseGet()`, it retrieves value wrapped inside an `Optional` object if it is present and its argument otherwise. Instead of returning a default value when wrapped value is not present, it throws an exception.\r\n\r\n    ```java\r\n    Optional\u003cString\u003e messageOptional = …;\r\n    String message = messageOptional.orElseThrow(() -\u003e new IllegalArgumentException());\r\n    ```\r\n\r\n    Or\r\n\r\n    ```java\r\n    Optional\u003cString\u003e messageOptional = …;\r\n    String message = messageOptional.orElseThrow(IllegalArgumentException::new);\r\n    ```\r\n\r\n- `get()`\r\n\r\n  - Can only return value if it is present, otherwise, it returns `NoSuchElementException`.\r\n\r\n    ```java\r\n    Optional\u003cString\u003e messageOptional = …;\r\n    String message = messageOptional.get();\r\n    ```\r\n\r\n    Make sure to be defensive against possible `NoSuchElementException` when using this method:\r\n\r\n    ```java\r\n    String message = messageOptional.isPresent() ? messageOptional.get() : “Welcome!”;\r\n    ```\r\n\r\n- `filter()`\r\n\r\n  - If a value is present, and the value matches the given predicate, return an `Optional` describing the value, otherwise return an empty `Optional`.\r\n\r\n    Example\r\n\r\n    ```java\r\n    Optional\u003cString\u003e answerOptional = Optional.of(“YES”)\r\n        .filter(b -\u003e b.equalsIgnorecase(“yes”));\r\n    ```\r\n\r\n  - If a value is present, and the value matches the given predicate, return an `Optional` describing the value, otherwise return an empty `Optional`.\r\n\r\n    Example\r\n\r\n    ```java\r\n    LocalDate birthday = LocalDate.of(2000, 7, 23);\r\n    Optional\u003cLocalDate\u003e legalAgeOptional1 = Optional.of(birthday)\r\n        .filter(this::isLegalAge);\r\n    ```\r\n\r\n    ```java\r\n    public boolean isLegalAge(LocalDate birthday) {\r\n      LocalDate currentDate = LocalDate.now(); // 2019-5-24\r\n      Period interval = Period.between(birthday, currentDate);\r\n\r\n      return interval.getYears() \u003e 17;\r\n    }\r\n    ```\r\n\r\n    Above code will return `Optional` with a LocalDate value since filter meets the predicate.\r\n\r\n- `map()`\r\n\r\n  - Transforms value - if a value is present, apply the provided mapping function to it, and if the result is non-null, return an `Optional` describing the result. Otherwise return an empty `Optional`.\r\n\r\n    Example 1\r\n\r\n    ```java\r\n    List\u003cString\u003e frameworks = Arrays.asList(\"Spring\", “Spring Fu”, \"Quarkus\", \"Micronaut\", \"Play\", \"Struts\", \"Spark\", \"Summer Fun\");\r\n    Optional\u003cList\u003cString\u003e\u003e listOptional = Optional.of(frameworks);\r\n    int size = listOptional\r\n        .map(List::size) // Lambda expression .map(list -\u003e list.size())\r\n        .orElse(0);\r\n    ```\r\n\r\n    Above code will return an integer value since mapping function is to get the size of `List`.\r\n\r\n    Example 2\r\n\r\n    ```java\r\n    class Person {\r\n      public Optional\u003cString\u003e getName() {\r\n        return Optional.of(\"Digong\");\r\n      }\r\n    }\r\n    ```\r\n\r\n    ```java\r\n    Person person = new Person();\r\n    Optional\u003cPerson\u003e personOptional = Optional.of(person);\r\n    Optional\u003cOptional\u003cString\u003e\u003e nameOptionalWrapper = personOptional.map(Person::getName);\r\n    Optional\u003cString\u003e nameOptional = nameOptionalWrapper.orElse(Optional.empty());\r\n    String name = nameOptional.orElse(\"\");\r\n    ```\r\n\r\n    With `.map()`, we still need to get `Optional` that wraps another `Optional` (line 3). Then, `.orElse()`, line 4, gets the `Optional` wrapped in `Optional`. Finally, the last `.orElse()` extracts the name value.\r\n\r\n- `flatMap()`\r\n\r\n  - If a value is present, apply the provided `Optional`-bearing mapping function to it, return that result, otherwise return an empty `Optional`. This method is similar to `map()`, but the provided mapper is one whose result is already an `Optional`, and if invoked, `flatMap()` does not wrap it with an additional `Optional`.\r\n\r\n    ```java\r\n    Person person = new Person();\r\n    Optional\u003cPerson\u003e personOptional = Optional.of(person);\r\n    Optional\u003cString\u003e nameOptional = personOptional.flatMap(Person::getName);\r\n    // Lambda expression: personOptional.flatMap(p -\u003e p.getName());\r\n    String name = nameOptional.orElse(\"\");\r\n    ```\r\n\r\n    `.flatMap()` already returns the `Optional` wrapped in another `Optional`. We have saved a single line.\r\n\r\n### Stream API\r\n\r\n- A sequence of elements supporting sequential and parallel aggregate operations.\r\n- Collections in Java 8 are extended so you can simply create streams either by calling `Collection.stream()` or `Collection.parallelStream()`\r\n- `Stream` operations are either **intermediate** or **terminal**\r\n  - **Intermediate operations** return the `Stream` itself so you can chain multiple method calls in a row\r\n    - `filter`\r\n    - `sorted`\r\n    - `map`\r\n  - **Terminal operations** return a result of a certain type\r\n    - `forEach`\r\n    - `allMatch`\r\n    - `findFirst`\r\n    - `count`\r\n    - `reduce`\r\n    - `collect`\r\n\r\n#### Stream - filter()\r\n\r\nReturns a stream consisting of the elements of this stream that match the given predicate.\r\n\r\nExample:\r\n\r\n```java\r\nList\u003cString\u003e frameworks = new ArrayList\u003c\u003e();\r\nframeworks.add(\"Spring\");\r\nframeworks.add(\"Spring Fu\");\r\nframeworks.add(\"Quarkus\");\r\nframeworks.add(\"Micronaut\");\r\nframeworks.add(\"Play\");\r\nframeworks.add(\"Struts\");\r\nframeworks.add(\"Spark\");\r\nframeworks.add(\"Summer Fun\");\r\n\r\nList\u003cString\u003e frameworks = frameworks();\r\nList\u003cString\u003e frameworksStartWithS = frameworks.stream()\r\n        .filter(framework -\u003e framework.startsWith(\"S\"))\r\n        .collect(Collectors.toList());\r\n```\r\n\r\n#### Stream - sorted()\r\n\r\nReturns a stream consisting of the elements of this stream, sorted according to natural order.\r\n\r\nExample\r\n\r\n```java\r\nList\u003cString\u003e frameworks = frameworks();\r\nList\u003cString\u003e frameworksSorted = frameworks.stream()\r\n        .sorted()\r\n        .collect(Collectors.toList());\r\n\r\n// reversed\r\nList\u003cString\u003e frameworksReversed = frameworks.stream()\r\n        .sorted(Collections.reverseOrder())\r\n        .collect(Collectors.toList());\r\n```\r\n\r\n#### Stream - map()\r\n\r\nReturns a stream consisting of the results of applying the given function to the elements of this stream.\r\n\r\nExample\r\n\r\n```java\r\nList\u003cString\u003e frameworks = frameworks();\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nList\u003cString\u003e frameworksToUpperCase = frameworks.stream()\r\n        .map(framework -\u003e framework.toUpperCase())\r\n        .collect(Collectors.toList());\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nList\u003cString\u003e frameworksToUpperCase = frameworks.stream()\r\n        .map(String::toUpperCase)\r\n        .collect(Collectors.toList());\r\n```\r\n\r\n#### Stream - forEach()\r\n\r\nReturns an iterator over elements.\r\n\r\nExample\r\n\r\n```java\r\nList\u003cString\u003e frameworks = frameworks();\r\n```\r\n\r\nLambda Expression\r\n\r\n```java\r\nframeworks.forEach(framework -\u003e System.out.println(framework));\r\n```\r\n\r\nMethod Reference\r\n\r\n```java\r\nframeworks.forEach(System.out::println);\r\n```\r\n\r\n#### Stream - allMatch()\r\n\r\nReturns whether all elements of this stream match the provided predicate.\r\n\r\nExample\r\n\r\n```java\r\nList\u003cString\u003e frameworks = frameworks();\r\nboolean allMatched = frameworks.stream()\r\n        .allMatch(framework -\u003e framework.split(\" \").length \u003e 1);\r\n```\r\n\r\n#### Stream - findFirst()\r\n\r\nReturns whether all elements of this stream match the provided predicate.\r\n\r\nExample\r\n\r\n```java\r\nList\u003cString\u003e frameworks = frameworks();\r\nOptional\u003cString\u003e frameworkOptional = frameworks.stream()\r\n        .filter(framework -\u003e framework.contains(\"Fund\"))\r\n        .findFirst();\r\n```\r\n\r\n#### Stream - count()\r\n\r\nReturns the count of elements in this stream.\r\n\r\nExample\r\n\r\n```java\r\nList\u003cString\u003e frameworks = frameworks();\r\nlong countAll = frameworks.stream()\r\n        .count();\r\nlong countStartsWithS = frameworks.stream()\r\n        .filter(framework -\u003e framework.startsWith(\"S\"))\r\n        .count();\r\n```\r\n\r\n#### Stream - reduce()\r\n\r\nPerforms a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.\r\n\r\nExample\r\n\r\n```java\r\nInteger[] grades = {90, 85, 92, 98, 88, 93};\r\nOptional\u003cInteger\u003e totalOptional = Stream.of(grades)\r\n        .reduce((g1, g2) -\u003e g1 + g2);\r\ntotalOptional.ifPresent(System.out::println);\r\n```\r\n\r\n#### Stream - collect()\r\n\r\nPerforms a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.\r\n\r\nExample 1\r\n\r\n```java\r\nInteger[] grades = {90, 85, 92, 98, 88, 93};\r\nList\u003cInteger\u003e gradeList = Stream.of(grades)\r\n        .filter(grade -\u003e grade \u003e 89)\r\n        .collect(Collectors.toList());\r\n```\r\n\r\nExample 2\r\n\r\n```java\r\nList\u003cUser\u003e users = Arrays.asList(\r\nnew User(\"John\", \"ADMIN\"),\r\nnew User(\"Luke\", \"USER\"),\r\nnew User(\"Matthew\", \"USER\"),\r\nnew User(\"Mark\", \"USER\"),\r\nnew User(\"Paul\", \"ADMIN\"));\r\n\r\nMap\u003cString, User\u003e userMap = users.stream()\r\n        .collect(Collectors.toMap(User::getRole, user -\u003e user));\r\n```\r\n\r\n### New Date and Time API\r\n\r\n- The Date-Time APIs, introduced in JDK 8, are a set of packages that model the most important aspects of date and time\r\n- The core classes in the java.time package use the calendar system defined in **ISO-8601** (based on the Gregorian calendar system) as the default calendar.\r\n  - `java.time` - Classes for date, time, date and time combined, time zones, instants, duration, and clocks.\r\n  - `java.time.chrono` - API for representing calendar systems other than ISO-8601. Several predefined chronologies are provided and you can also define your own chronology.\r\n  - `java.time.format` - Classes for formatting and parsing dates and time.\r\n  - `java.time.temporal` - Extended API, primarily for framework and library writers, allowing interoperations between the date and time classes, querying, and adjustment. Fields and units are defined in this package.\r\n  - `java.time.zone` - Classes that support time zones, offsets from time zones, and time zone rules. on the Gregorian calendar system) as the default calendar.\r\n- Old Date API\r\n  - Existing classes aren’t thread-safe, leading to potential concurrency issues for users—not something the average developer would expect to deal with when writing date-handling code.\r\n  - Some of the date and time classes also exhibit quite poor API design. For example, years in `java.util.Date` start at 1900, months start at 1, and days start at 0—not very intuitive.\r\n  - These issues, and several others, have led to the popularity of third-party date and time libraries, such as Joda-Time.\r\n\r\nThe project, **Date and Time API**, has been led jointly by the author of **Joda-Time** (**Stephen Colebourne**) and Oracle, under **JSR 310**, and appears in the new Java SE 8 package `java.time`.\r\n\r\n#### New Date and Time API - Clock\r\n\r\n**Clock**\r\n\r\n- A clock providing access to the current instant, date and time using a time-zone.\r\n\r\nExample\r\n\r\n```java\r\nClock clock = Clock.systemDefaultZone();\r\nlong millis = clock.millis();\r\n\r\nInstant instant = clock.instant();\r\nDate legacyDate = Date.from(instant);\r\n```\r\n\r\n#### New Date and Time API - Timezone\r\n\r\n**ZoneId**\r\n\r\n- A time-zone ID, such as `Asia/Manila`. A `ZoneId` is used to identify the rules used to convert between, an `Instant` and a `LocalDateTime`.\r\n\r\nExample\r\n\r\n```java\r\nSet\u003cZoneId\u003e availableZoneIds = ZoneId.getAvailableZoneIds();\r\n```\r\n\r\n```java\r\nZoneId zone1 = ZoneId.of(\"Asia/Manila\");\r\nZoneId zone2 = ZoneId.of(\"Europe/Paris\");\r\nSystem.out.println(zone1.getRules());   // ZoneRules[currentStandardOffset=+08:00]\r\nSystem.out.println(zone2.getRules());   // ZoneRules[currentStandardOffset=+01:00]\r\n```\r\n\r\n#### New Date and Time API - LocalTime\r\n\r\n**LocalTime**\r\n\r\n- A time without a time-zone in the ISO-8601 calendar system, such as `08:24:15`.\r\n\r\nExample\r\n\r\n```java\r\nZoneId zone1 = ZoneId.of(\"Asia/Manila\");\r\nZoneId zone2 = ZoneId.of(\"Europe/Paris\");\r\nLocalTime now1 = LocalTime.now(zone1);\r\nLocalTime now2 = LocalTime.now(zone2);\r\n\r\nSystem.out.println(now1.isBefore(now2));  // false\r\n\r\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\r\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\r\n\r\nSystem.out.println(hoursBetween);       // -6\r\nSystem.out.println(minutesBetween);     // -360\r\n```\r\n\r\n#### New Date and Time API - LocalDate\r\n\r\n**LocalDate**\r\n\r\n- A date without a time-zone in the ISO-8601 calendar system, such as `2019-05-24`.\r\n\r\nExample\r\n\r\n```java\r\nLocalDate today = LocalDate.now();\r\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\r\nLocalDate yesterday = tomorrow.minusDays(2);\r\n\r\nLocalDate independenceDay = LocalDate.of(2019, Month.MAY, 24);\r\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\r\nSystem.out.println(dayOfWeek);    // FRIDAY\r\n```\r\n\r\n#### New Date and Time API - LocalDateTime\r\n\r\n**LocalDateTime**\r\n\r\n- A date-time without a time-zone in the ISO-8601 calendar system, such as `2019-05-24T08:24:15`.\r\n\r\nExample\r\n\r\n```java\r\nLocalDateTime ldt = LocalDateTime.of(2019, Month.MAY, 24, 14, 55, 59);\r\n\r\nDayOfWeek dayOfWeek = ldt.getDayOfWeek();\r\nSystem.out.println(dayOfWeek);      // FRIDAY\r\n\r\nMonth month = ldt.getMonth();\r\nSystem.out.println(month);          // MAY\r\n\r\nlong minuteOfDay = ldt.getLong(ChronoField.MINUTE_OF_DAY);\r\nSystem.out.println(minuteOfDay);    // 895\r\n```\r\n\r\n---\r\n\r\n# References\r\n\r\n1. https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8\r\n2. https://www.tutorialspoint.com/java8/index.htm\r\n3. https://winterbe.com/posts/2014/03/16/java-8-tutorial/\r\n4. https://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html\r\n5. https://www.baeldung.com/java-optional\r\n6. https://www.baeldung.com/java-8-streams\r\n7. https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html\r\n"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"java-8-new-language-features"},"buildId":"ywGPERTp6BisonP7U8tUh","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/runtime/polyfills-ac8b02fa82de57111615.js"></script><script async="" data-next-page="/blog/[slug]" src="/_next/static/ywGPERTp6BisonP7U8tUh/pages/blog/%5Bslug%5D.js"></script><script async="" data-next-page="/_app" src="/_next/static/ywGPERTp6BisonP7U8tUh/pages/_app.js"></script><script src="/_next/static/runtime/webpack-b65cab0b00afd201cbda.js" async=""></script><script src="/_next/static/chunks/framework.4503cc20512dbab0b6d3.js" async=""></script><script src="/_next/static/chunks/07fdf76e751aca78a46eb975a54a24e4b4193c25.627b6b3615d0d2a4c6c1.js" async=""></script><script src="/_next/static/runtime/main-11312f39460057087083.js" async=""></script><script src="/_next/static/chunks/a9a7754c.29c45f57a1035e7b8fe9.js" async=""></script><script src="/_next/static/chunks/100a3ba0b69c26a511790651df7de2bbf06df0e5.0b49a536fe8cdc6d5399.js" async=""></script><script src="/_next/static/ywGPERTp6BisonP7U8tUh/_buildManifest.js" async=""></script><script src="/_next/static/ywGPERTp6BisonP7U8tUh/_ssgManifest.js" async=""></script><script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script><script src="/assets/vendor/prismjs/prism.js"></script><script id="dsq-count-scr" src="//julianjupitergithubio.disqus.com/count.js"></script><script src="/assets/js/google_analytics.js"></script></body></html>